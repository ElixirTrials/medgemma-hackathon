---
phase: 05-entity-grounding-workflow
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - services/agent-b-service/src/agent_b_service/nodes/__init__.py
  - services/agent-b-service/src/agent_b_service/nodes/extract_entities.py
  - services/agent-b-service/src/agent_b_service/nodes/ground_to_umls.py
  - services/agent-b-service/src/agent_b_service/nodes/map_to_snomed.py
  - services/agent-b-service/src/agent_b_service/nodes/validate_confidence.py
  - services/agent-b-service/src/agent_b_service/graph.py
  - services/api-service/src/api_service/main.py
autonomous: true

must_haves:
  truths:
    - "4-node LangGraph StateGraph compiles: extract_entities -> ground_to_umls -> map_to_snomed -> validate_confidence"
    - "extract_entities node loads criteria text from DB and calls MedGemma/Gemini for structured entity extraction with span positions"
    - "ground_to_umls node calls UMLS MCP server via langchain-mcp-adapters for tiered concept linking"
    - "validate_confidence node validates CUI codes against UMLS REST API, persists Entity records, and publishes EntitiesGrounded event"
    - "CriteriaExtracted events are dispatched to handle_criteria_extracted handler via outbox processor in api-service"
    - "Failed grounding stores free-text entity with method=expert_review without blocking the pipeline"
  artifacts:
    - path: "services/agent-b-service/src/agent_b_service/nodes/extract_entities.py"
      provides: "Entity extraction node using ChatVertexAI with structured output"
      contains: "extract_entities_node"
    - path: "services/agent-b-service/src/agent_b_service/nodes/ground_to_umls.py"
      provides: "UMLS grounding node using MCP server via langchain-mcp-adapters"
      contains: "ground_to_umls_node"
    - path: "services/agent-b-service/src/agent_b_service/nodes/map_to_snomed.py"
      provides: "SNOMED-CT mapping node with code lookup for grounded entities"
      contains: "map_to_snomed_node"
    - path: "services/agent-b-service/src/agent_b_service/nodes/validate_confidence.py"
      provides: "Validation and persistence node: CUI validation, Entity creation, EntitiesGrounded event"
      contains: "validate_confidence_node"
    - path: "services/agent-b-service/src/agent_b_service/graph.py"
      provides: "4-node StateGraph with conditional error routing after extract_entities and ground_to_umls"
      contains: "StateGraph"
    - path: "services/api-service/src/api_service/main.py"
      provides: "OutboxProcessor with criteria_extracted handler registration"
      contains: "criteria_extracted"
  key_links:
    - from: "services/agent-b-service/src/agent_b_service/nodes/extract_entities.py"
      to: "langchain_google_vertexai"
      via: "ChatVertexAI.with_structured_output(BatchEntityExtractionResult)"
      pattern: "with_structured_output"
    - from: "services/agent-b-service/src/agent_b_service/nodes/ground_to_umls.py"
      to: "services/umls-mcp-server/src/umls_mcp_server/server.py"
      via: "langchain-mcp-adapters MultiServerMCPClient with stdio transport"
      pattern: "MultiServerMCPClient"
    - from: "services/agent-b-service/src/agent_b_service/nodes/validate_confidence.py"
      to: "libs/events-py/src/events_py/outbox.py"
      via: "persist_with_outbox for EntitiesGrounded event"
      pattern: "persist_with_outbox"
    - from: "services/api-service/src/api_service/main.py"
      to: "services/agent-b-service/src/agent_b_service/trigger.py"
      via: "OutboxProcessor handler registration for criteria_extracted event"
      pattern: "handle_criteria_extracted"
---

<objective>
Implement the 4 grounding workflow nodes, assemble the LangGraph StateGraph with conditional error routing, and wire the CriteriaExtracted event handler into the api-service outbox processor. This completes the end-to-end grounding pipeline: CriteriaExtracted event -> entity extraction -> UMLS grounding -> SNOMED mapping -> validation and persistence -> EntitiesGrounded event.

Purpose: This is the integration plan that brings together all Phase 5 building blocks into a working pipeline, following the same pattern as Phase 3 Plan 02.
Output: Complete working grounding pipeline triggered by CriteriaExtracted events.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-entity-grounding-workflow/05-RESEARCH.md
@.planning/phases/03-criteria-extraction-workflow/03-02-SUMMARY.md

Key reference files (read during execution):
- services/agent-a-service/src/agent_a_service/graph.py (graph assembly pattern)
- services/agent-a-service/src/agent_a_service/nodes/ (node implementation patterns)
- services/agent-a-service/src/agent_a_service/nodes/queue.py (persist_with_outbox pattern)
- services/api-service/src/api_service/main.py (outbox handler registration)
- libs/events-py/src/events_py/outbox.py (persist_with_outbox API)
- libs/events-py/src/events_py/models.py (DomainEventKind.ENTITIES_GROUNDED)
- libs/shared/src/shared/models.py (Entity model fields)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 4 grounding workflow nodes</name>
  <files>
    services/agent-b-service/src/agent_b_service/nodes/__init__.py
    services/agent-b-service/src/agent_b_service/nodes/extract_entities.py
    services/agent-b-service/src/agent_b_service/nodes/ground_to_umls.py
    services/agent-b-service/src/agent_b_service/nodes/map_to_snomed.py
    services/agent-b-service/src/agent_b_service/nodes/validate_confidence.py
  </files>
  <action>
**IMPORTANT**: Delete the old `services/agent-b-service/src/agent_b_service/nodes.py` file (singular) and create a `nodes/` package directory instead (same refactor as Phase 3 Plan 02 did for agent-a).

1. **nodes/__init__.py** -- Re-export all 4 node functions:
   ```python
   from .extract_entities import extract_entities_node
   from .ground_to_umls import ground_to_umls_node
   from .map_to_snomed import map_to_snomed_node
   from .validate_confidence import validate_confidence_node
   ```

2. **nodes/extract_entities.py** -- `async def extract_entities_node(state: GroundingState) -> dict[str, Any]`:
   - Early return `{}` if `state.get("error")`.
   - Load criteria texts from DB: `Session(engine)` with `session.get(Criteria, cid)` for each ID in `state["criteria_ids"]`. Build `criteria_texts` list of `{"id": c.id, "text": c.text, "criteria_type": c.criteria_type, "category": c.category}`.
   - Import engine from `api_service.storage` (cross-service import pattern from Phase 3).
   - Render prompts: Load system.jinja2 and user.jinja2 from `agent_b_service/prompts/` using Jinja2 `Environment(loader=PackageLoader(...))`. Render user prompt with `criteria=criteria_texts`.
   - Determine model: Check `os.getenv("ENTITY_EXTRACTION_MODEL", "gemini")`. If "gemini", use `ChatVertexAI(model="gemini-2.5-flash")`. If "medgemma", use `ChatVertexAI(model=os.getenv("MEDGEMMA_ENDPOINT", "medgemma-1.5-4b-it"))`.
   - Call LLM: `llm.with_structured_output(BatchEntityExtractionResult)` with system + user messages.
   - **Span validation** (Pitfall 4): After extraction, for each entity check `criterion_text[span_start:span_end] == entity.text`. If misaligned, use `criterion_text.find(entity.text)` to correct spans. Log corrections.
   - Convert to raw_entities list of dicts: `{"criteria_id", "text", "entity_type", "span_start", "span_end", "context_window"}`.
   - Return `{"criteria_texts": criteria_texts, "raw_entities": raw_entities}`.
   - Wrap in try/except, return `{"error": f"Entity extraction failed: {e}"}` on failure.

3. **nodes/ground_to_umls.py** -- `async def ground_to_umls_node(state: GroundingState) -> dict[str, Any]`:
   - Early return `{}` if `state.get("error")`.
   - Use `langchain_mcp_adapters.client.MultiServerMCPClient` with stdio transport config:
     ```python
     mcp_config = {
         "umls": {
             "command": "uv",
             "args": ["run", "python", "-m", "umls_mcp_server.server"],
             "transport": "stdio",
         }
     }
     ```
     Note: Use `"uv"` as command (not `"python"`) per project convention (CLAUDE.md: always use uv run).
   - Alternatively, if `langchain-mcp-adapters` is not available or MCP server cannot start, fall back to **direct UMLS client mode**: import `get_umls_client` from `umls_mcp_server.umls_api` and call `client.search()` directly. Wrap the MCP attempt in try/except and fall back gracefully.
   - For each entity in `state["raw_entities"]`, call `concept_linking` tool (or direct client) with `term=entity["text"]`, `context=entity.get("context_window", "")`.
   - Build grounded entity dict: merge original entity fields with `umls_cui`, `preferred_term`, `grounding_confidence`, `grounding_method` from grounding result.
   - **Never block pipeline on failed grounding** (Pitfall 5 / Anti-pattern): If any single entity fails, set `grounding_method="expert_review"`, `grounding_confidence=0.0`, `umls_cui=None` and continue.
   - Return `{"grounded_entities": grounded}`.
   - Wrap in try/except, return `{"error": f"UMLS grounding failed: {e}"}` on failure.

4. **nodes/map_to_snomed.py** -- `async def map_to_snomed_node(state: GroundingState) -> dict[str, Any]`:
   - Early return `{}` if `state.get("error")` or no grounded_entities.
   - For each grounded entity with a `umls_cui`, call `get_snomed_code_for_cui(cui)` from `agent_b_service.umls_client`.
   - Set `snomed_code` on each entity dict. If no SNOMED mapping found, leave as None (not an error).
   - Return `{"grounded_entities": updated_entities}` (overwrite with SNOMED codes added).
   - This node does NOT use conditional error routing -- it always proceeds to validate_confidence (same pattern as parse->queue in agent-a).

5. **nodes/validate_confidence.py** -- `async def validate_confidence_node(state: GroundingState) -> dict[str, Any]`:
   - For each grounded entity with a `umls_cui`, call `validate_cui(cui)` from `agent_b_service.umls_client`. If validation fails, clear `umls_cui`, `snomed_code`, set `grounding_method="expert_review"`, `grounding_confidence=0.0`. Log a warning.
   - Persist Entity records: `Session(engine)` from `api_service.storage`. For each entity, create `Entity(...)` SQLModel instance mapping all fields from the grounded entity dict to the Entity model columns. Use `session.add(entity)`, `session.flush()` to get IDs.
   - Set `review_status="pending"` if `grounding_method == "expert_review"`, else None.
   - Update CriteriaBatch status: `session.get(CriteriaBatch, state["batch_id"])`, set `status = "entities_grounded"`.
   - Publish EntitiesGrounded event: Use `persist_with_outbox(session, batch, DomainEventKind.ENTITIES_GROUNDED, "criteria_batch", state["batch_id"], payload={...})`. Payload includes: `batch_id`, `protocol_id`, `entity_ids`, `entity_count`, `expert_review_count`.
   - `session.commit()`.
   - Return `{"entity_ids": entity_ids}`.
  </action>
  <verify>
Run `uv run python -c "from agent_b_service.nodes import extract_entities_node, ground_to_umls_node, map_to_snomed_node, validate_confidence_node; print('OK')"` to verify all node functions import.
Run `uv run ruff check services/agent-b-service/src/agent_b_service/nodes/` to verify lint clean.
  </verify>
  <done>4 grounding workflow nodes implemented: extract_entities (ChatVertexAI structured output with span validation), ground_to_umls (MCP server with direct fallback), map_to_snomed (SNOMED code lookup), validate_confidence (CUI validation + Entity persistence + EntitiesGrounded event). Old nodes.py deleted and replaced with nodes/ package.</done>
</task>

<task type="auto">
  <name>Task 2: Graph assembly and api-service handler registration</name>
  <files>
    services/agent-b-service/src/agent_b_service/graph.py
    services/api-service/src/api_service/main.py
  </files>
  <action>
1. **graph.py** -- Replace the 2-node placeholder with 4-node grounding StateGraph (follow agent-a graph.py pattern exactly):
   - Import `GroundingState` from `.state`
   - Import all 4 node functions from `.nodes`
   - `should_continue(state: GroundingState) -> str`: Return "error" if `state.get("error")` else "continue"
   - `create_graph()`:
     - `workflow = StateGraph(GroundingState)`
     - Add 4 nodes: extract_entities, ground_to_umls, map_to_snomed, validate_confidence
     - Edge flow: START -> extract_entities -> [conditional] -> ground_to_umls -> [conditional] -> map_to_snomed -> validate_confidence -> END
     - Conditional error routing after extract_entities and ground_to_umls (same as ingest/extract in agent-a)
     - map_to_snomed -> validate_confidence is unconditional (same as parse -> queue in agent-a)
     - `return workflow.compile()`
   - Singleton `_graph` and `get_graph()` pattern (identical to agent-a)

2. **api-service main.py** -- Register CriteriaExtracted handler:
   - Add import: `from agent_b_service.trigger import handle_criteria_extracted`
   - Update OutboxProcessor handlers dict to include: `"criteria_extracted": [handle_criteria_extracted]`
   - Keep existing `"protocol_uploaded": [handle_protocol_uploaded]` handler

3. **Verify graph compiles**: Run `uv run python -c "from agent_b_service.graph import get_graph; g = get_graph(); print(type(g).__name__)"` -- should print `CompiledStateGraph`.
  </action>
  <verify>
Run `uv run python -c "from agent_b_service.graph import get_graph; g = get_graph(); print(type(g).__name__)"` to verify graph compiles as CompiledStateGraph.
Run `uv run ruff check services/agent-b-service/src/agent_b_service/graph.py services/api-service/src/api_service/main.py` to verify lint clean.
Run `uv run mypy services/agent-b-service/src/agent_b_service/graph.py --ignore-missing-imports` to verify type safety.
Run `uv run pytest` to verify all existing tests pass with no regressions.
  </verify>
  <done>4-node LangGraph StateGraph compiles and routes: extract_entities -> ground_to_umls -> map_to_snomed -> validate_confidence. CriteriaExtracted events dispatched to handle_criteria_extracted handler via outbox processor. End-to-end grounding pipeline wired.</done>
</task>

</tasks>

<verification>
- `uv run python -c "from agent_b_service.graph import get_graph; g = get_graph(); print(type(g).__name__)"` returns CompiledStateGraph
- `uv run python -c "from agent_b_service.nodes import extract_entities_node, ground_to_umls_node, map_to_snomed_node, validate_confidence_node; print('All 4 nodes OK')"` succeeds
- `uv run python -c "from api_service.main import app; print('OK')"` succeeds (main.py with both handlers loads)
- `uv run ruff check services/agent-b-service/ services/api-service/` passes clean
- `uv run pytest` passes with no regressions
- Graph has conditional error routing after extract_entities and ground_to_umls nodes
</verification>

<success_criteria>
- 4-node grounding StateGraph compiles with conditional error routing
- extract_entities uses ChatVertexAI with env-var toggled model (gemini default, medgemma optional)
- ground_to_umls calls UMLS MCP server via langchain-mcp-adapters with direct API fallback
- validate_confidence validates CUI codes, persists Entity records, publishes EntitiesGrounded event
- CriteriaExtracted events trigger the grounding pipeline end-to-end via outbox processor
- Failed grounding does not block pipeline (stores free-text + expert_review method)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-entity-grounding-workflow/05-03-SUMMARY.md`
</output>
