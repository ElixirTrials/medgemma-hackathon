---
phase: 05-entity-grounding-workflow
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - services/agent-b-service/src/agent_b_service/state.py
  - services/agent-b-service/src/agent_b_service/schemas/__init__.py
  - services/agent-b-service/src/agent_b_service/schemas/entities.py
  - services/agent-b-service/src/agent_b_service/prompts/system.jinja2
  - services/agent-b-service/src/agent_b_service/prompts/user.jinja2
  - services/agent-b-service/src/agent_b_service/trigger.py
  - services/agent-b-service/src/agent_b_service/umls_client.py
  - services/agent-b-service/src/agent_b_service/__init__.py
  - services/agent-b-service/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "GroundingState TypedDict defines the complete data contract for 4-node grounding workflow"
    - "Pydantic EntityExtractionResult schema works with ChatVertexAI.with_structured_output() for structured entity extraction"
    - "Trigger handler bridges CriteriaExtracted events to the grounding graph via asyncio.run()"
    - "UMLS validation client validates CUI codes against UMLS REST API before storage"
    - "Entity types cover all 6 required categories: Condition, Medication, Procedure, Lab_Value, Demographic, Biomarker"
  artifacts:
    - path: "services/agent-b-service/src/agent_b_service/state.py"
      provides: "GroundingState TypedDict with 8 fields for grounding workflow"
      contains: "GroundingState"
    - path: "services/agent-b-service/src/agent_b_service/schemas/entities.py"
      provides: "EntityType enum, ExtractedEntity, EntityExtractionResult, BatchEntityExtractionResult Pydantic models"
      contains: "EntityType"
    - path: "services/agent-b-service/src/agent_b_service/trigger.py"
      provides: "handle_criteria_extracted event handler with asyncio.run() bridge"
      contains: "handle_criteria_extracted"
    - path: "services/agent-b-service/src/agent_b_service/umls_client.py"
      provides: "validate_cui and get_snomed_code_for_cui async functions"
      contains: "validate_cui"
    - path: "services/agent-b-service/src/agent_b_service/prompts/system.jinja2"
      provides: "Medical entity extraction system prompt with 6 entity types and output format"
      contains: "Condition"
  key_links:
    - from: "services/agent-b-service/src/agent_b_service/trigger.py"
      to: "services/agent-b-service/src/agent_b_service/graph.py"
      via: "lazy import of get_graph() and asyncio.run(graph.ainvoke())"
      pattern: "get_graph.*ainvoke"
    - from: "services/agent-b-service/src/agent_b_service/schemas/entities.py"
      to: "langchain_google_vertexai"
      via: "Pydantic schema used with ChatVertexAI.with_structured_output()"
      pattern: "BaseModel"
---

<objective>
Build the foundation for agent-b's grounding workflow: GroundingState TypedDict, Pydantic entity extraction schemas, Jinja2 prompts for MedGemma/Gemini entity extraction, UMLS code validation client, and the CriteriaExtracted event trigger handler.

Purpose: These are the building blocks that the graph nodes (Plan 05-03) will use. This follows the same pattern as Phase 3 Plan 01 -- build state, schemas, prompts, and trigger first, then assemble nodes and graph in the next plan.
Output: Complete agent-b-service foundation ready for graph node implementation.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-entity-grounding-workflow/05-RESEARCH.md
@.planning/phases/03-criteria-extraction-workflow/03-01-SUMMARY.md

Key reference files (read during execution):
- services/agent-a-service/src/agent_a_service/state.py (ExtractionState pattern)
- services/agent-a-service/src/agent_a_service/schemas/criteria.py (Pydantic schema pattern)
- services/agent-a-service/src/agent_a_service/trigger.py (trigger handler pattern)
- services/agent-a-service/src/agent_a_service/prompts/ (Jinja2 prompt pattern)
- services/agent-b-service/src/agent_b_service/ (current placeholder to replace)
</context>

<tasks>

<task type="auto">
  <name>Task 1: GroundingState, Pydantic entity schemas, and Jinja2 prompts</name>
  <files>
    services/agent-b-service/src/agent_b_service/state.py
    services/agent-b-service/src/agent_b_service/schemas/__init__.py
    services/agent-b-service/src/agent_b_service/schemas/entities.py
    services/agent-b-service/src/agent_b_service/prompts/system.jinja2
    services/agent-b-service/src/agent_b_service/prompts/user.jinja2
  </files>
  <action>
1. **state.py** -- Replace the existing AgentState placeholder with GroundingState TypedDict:
   ```python
   class GroundingState(TypedDict):
       batch_id: str
       protocol_id: str
       criteria_ids: list[str]
       criteria_texts: list[dict[str, Any]]  # [{id, text, criteria_type, category}]
       raw_entities: list[dict[str, Any]]     # Extracted entities with spans
       grounded_entities: list[dict[str, Any]]  # Entities with UMLS/SNOMED codes
       entity_ids: list[str]                    # Persisted Entity record IDs
       error: str | None
   ```
   Follow the ExtractionState pattern from agent-a (TypedDict, not dataclass). Remove all AgentState references including the `add_messages` import.

2. **schemas/entities.py** -- Pydantic models for structured output (max 2 nesting levels per Phase 3 decision):
   - `EntityType(str, Enum)` with 6 values: Condition, Medication, Procedure, Lab_Value, Demographic, Biomarker
   - `ExtractedEntity(BaseModel)` with fields: `text: str`, `entity_type: EntityType`, `span_start: int`, `span_end: int`, `context_window: str` -- all with `Field(description=...)` for Gemini structured output guidance
   - `EntityExtractionResult(BaseModel)` with: `entities: list[ExtractedEntity]`, `criterion_id: str`
   - `BatchEntityExtractionResult(BaseModel)` with: `results: list[EntityExtractionResult]`
   Keep nesting to max 2 levels (BatchEntityExtractionResult -> EntityExtractionResult -> ExtractedEntity) matching the Phase 3 pattern.

3. **schemas/__init__.py** -- Re-export: `EntityType`, `ExtractedEntity`, `EntityExtractionResult`, `BatchEntityExtractionResult`.

4. **prompts/system.jinja2** -- System prompt for medical entity extraction (from research Example 1):
   - Role: "You are a medical entity extraction specialist"
   - 6 entity types with descriptions and examples
   - Output format: text, entity_type, span_start, span_end, context_window
   - Important rules: extract exact text, include numeric values with units, extract most specific term, do NOT extract generic terms
   - Do NOT include any Jinja2 variables -- this is a static system prompt

5. **prompts/user.jinja2** -- User prompt template:
   - Variables: `{{ criteria }}` (list of criteria with id, text, type, category)
   - Format: iterate over criteria, presenting each with its ID, type, category, and full text
   - Instruction: "Extract all medical entities from each criterion below."
  </action>
  <verify>
Run `uv run python -c "from agent_b_service.state import GroundingState; from agent_b_service.schemas import EntityType, ExtractedEntity, EntityExtractionResult, BatchEntityExtractionResult; print('OK')"` to confirm all imports work.
Run `uv run ruff check services/agent-b-service/src/agent_b_service/state.py services/agent-b-service/src/agent_b_service/schemas/` to verify lint clean.
  </verify>
  <done>GroundingState TypedDict replaces AgentState with 8 typed fields. Pydantic entity schemas with EntityType enum and 2-level nesting are importable. Jinja2 prompts define entity extraction instructions.</done>
</task>

<task type="auto">
  <name>Task 2: Trigger handler, UMLS validation client, and package updates</name>
  <files>
    services/agent-b-service/src/agent_b_service/trigger.py
    services/agent-b-service/src/agent_b_service/umls_client.py
    services/agent-b-service/src/agent_b_service/__init__.py
    services/agent-b-service/pyproject.toml
  </files>
  <action>
1. **trigger.py** -- Event handler for CriteriaExtracted (follow agent-a trigger.py pattern exactly):
   ```python
   def handle_criteria_extracted(payload: dict[str, Any]) -> None:
   ```
   - Extract `batch_id`, `protocol_id`, `criteria_ids` from payload
   - Construct initial GroundingState dict with empty lists for `criteria_texts`, `raw_entities`, `grounded_entities`, `entity_ids`, and `error: None`
   - Lazy import `from agent_b_service.graph import get_graph`
   - Call `asyncio.run(graph.ainvoke(initial_state))`
   - Wrap in try/except, log and re-raise on failure (same pattern as agent-a)
   - Include docstring explaining the asyncio.run() bridge rationale

2. **umls_client.py** -- Async UMLS validation functions (separate from MCP server -- these are used directly by the validate_confidence node):
   - `UMLS_API_KEY = os.getenv("UMLS_API_KEY", "")`
   - `UMLS_BASE_URL = "https://uts-ws.nlm.nih.gov/rest"`
   - `async def validate_cui(cui: str) -> bool`: Validate CUI exists via `GET /content/current/CUI/{cui}`. Return False if no API key or on error. Use httpx.AsyncClient with 30s timeout.
   - `async def get_snomed_code_for_cui(cui: str) -> str | None`: Get SNOMED-CT code for CUI via `GET /search/current` with `sabs=SNOMEDCT_US`, `returnIdType=code`. Return code string or None.
   - **Mock mode**: If `UMLS_API_KEY` is empty, `validate_cui` always returns `True` and `get_snomed_code_for_cui` always returns `"73211009"` (mock SNOMED code). Log a warning on first mock call.

3. **__init__.py** -- Update exports:
   - Replace `AgentState` with `GroundingState`
   - Keep `create_graph` and `get_graph` exports
   - Add `handle_criteria_extracted` export

4. **pyproject.toml** -- Update agent-b-service dependencies:
   - Add `events-py` (for outbox patterns, matching agent-a's deps)
   - Add `langchain-google-vertexai` (for ChatVertexAI in extract node)
   - Add `jinja2` (for prompt rendering)
   - Add `httpx` (for UMLS validation client)
   - Keep existing `shared` and `inference` deps
   - Add `events-py` to `[tool.uv.sources]` as workspace source
  </action>
  <verify>
Run `uv run python -c "from agent_b_service.trigger import handle_criteria_extracted; from agent_b_service.umls_client import validate_cui, get_snomed_code_for_cui; print('OK')"` to verify imports.
Run `uv run ruff check services/agent-b-service/src/agent_b_service/trigger.py services/agent-b-service/src/agent_b_service/umls_client.py` to verify lint clean.
Run `uv run pytest` to verify no regressions across all workspace tests.
  </verify>
  <done>Trigger handler bridges CriteriaExtracted events to grounding graph. UMLS validation client validates CUI codes with mock fallback for dev. Agent-b-service package updated with new deps and exports.</done>
</task>

</tasks>

<verification>
- `uv run python -c "from agent_b_service import GroundingState, create_graph, get_graph"` succeeds
- `uv run python -c "from agent_b_service.schemas import EntityType; print(list(EntityType))"` shows 6 entity types
- `uv run python -c "from agent_b_service.trigger import handle_criteria_extracted; print('OK')"` succeeds
- `uv run python -c "from agent_b_service.umls_client import validate_cui; import asyncio; print(asyncio.run(validate_cui('C0011849')))"` returns True (mock mode)
- `uv run ruff check services/agent-b-service/` passes clean
- `uv run pytest` passes with no regressions
</verification>

<success_criteria>
- GroundingState replaces AgentState in agent-b-service with 8 typed fields
- Pydantic entity schemas match Phase 3's 2-level nesting constraint
- System prompt covers all 6 entity types with extraction guidance
- Trigger handler follows agent-a pattern (sync handler, asyncio.run bridge, lazy import)
- UMLS validation client works in mock mode without API key
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-entity-grounding-workflow/05-02-SUMMARY.md`
</output>
