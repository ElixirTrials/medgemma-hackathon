---
phase: 20-medgemma-agentic-grounding
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - services/grounding-service/src/grounding_service/schemas/agentic_actions.py
  - services/grounding-service/src/grounding_service/prompts/agentic_system.jinja2
  - services/grounding-service/src/grounding_service/prompts/agentic_extract.jinja2
  - services/grounding-service/src/grounding_service/prompts/agentic_evaluate.jinja2
  - services/grounding-service/src/grounding_service/nodes/medgemma_ground.py
  - services/grounding-service/src/grounding_service/nodes/__init__.py
  - services/grounding-service/src/grounding_service/graph.py
  - services/grounding-service/src/grounding_service/state.py
  - services/grounding-service/tests/test_grounding_graph.py
autonomous: true

must_haves:
  truths:
    - "MedGemma extracts medical entities from criteria text and suggests UMLS search terms via the agentic loop"
    - "UMLS MCP concept_search is called for each entity, returning both CUI and SNOMED code in one call (no separate map_to_snomed)"
    - "MedGemma evaluates UMLS concept_search results and selects the best match with confidence score"
    - "Agentic loop iterates max 3 times per criterion, with each iteration refining search terms if initial results are unsatisfactory"
    - "Grounding graph has exactly 2 nodes: medgemma_ground -> validate_confidence (replaces 4-node pipeline)"
    - "Entities that fail JSON parsing or exhaust iterations fall back to expert_review with confidence 0.0"
    - "Common medical terms (acetaminophen, osteoarthritis, Heparin) get grounded with CUI + SNOMED via the agentic loop"
  artifacts:
    - path: "services/grounding-service/src/grounding_service/schemas/agentic_actions.py"
      provides: "Pydantic models for MedGemma agentic JSON responses (AgenticAction, ExtractedEntityAction, GroundingSelection)"
      contains: "class AgenticAction"
    - path: "services/grounding-service/src/grounding_service/nodes/medgemma_ground.py"
      provides: "medgemma_ground_node implementing the programmatic agentic loop"
      contains: "async def medgemma_ground_node"
    - path: "services/grounding-service/src/grounding_service/prompts/agentic_system.jinja2"
      provides: "System prompt instructing MedGemma to act as medical entity grounding agent outputting JSON"
      min_lines: 20
    - path: "services/grounding-service/src/grounding_service/graph.py"
      provides: "Simplified 2-node graph: medgemma_ground -> validate_confidence"
      contains: "medgemma_ground"
    - path: "services/grounding-service/src/grounding_service/state.py"
      provides: "Updated GroundingState with iteration_history field"
      contains: "iteration_history"
  key_links:
    - from: "services/grounding-service/src/grounding_service/nodes/medgemma_ground.py"
      to: "libs/inference/src/inference/config.py"
      via: "AgentConfig.from_env() for model configuration"
      pattern: "AgentConfig\\.from_env"
    - from: "services/grounding-service/src/grounding_service/nodes/medgemma_ground.py"
      to: "libs/inference/src/inference/model_garden.py"
      via: "create_model_loader for MedGemma model instantiation"
      pattern: "create_model_loader"
    - from: "services/grounding-service/src/grounding_service/nodes/medgemma_ground.py"
      to: "services/umls-mcp-server/src/umls_mcp_server/server.py"
      via: "MultiServerMCPClient invoking concept_search tool"
      pattern: "concept_search"
    - from: "services/grounding-service/src/grounding_service/graph.py"
      to: "services/grounding-service/src/grounding_service/nodes/medgemma_ground.py"
      via: "graph node registration"
      pattern: "medgemma_ground_node"
---

<objective>
Create the MedGemma agentic grounding node and rewire the grounding graph from 4 nodes to 2.

Purpose: Replace the Gemini-based entity extraction + separate UMLS grounding + separate SNOMED mapping pipeline with a single agentic node where MedGemma drives iterative entity extraction and UMLS grounding via MCP concept_search. This unifies extraction, grounding, and SNOMED mapping into one intelligent loop.

Output: New medgemma_ground node with Jinja2 prompts and Pydantic action schemas, simplified 2-node graph (medgemma_ground -> validate_confidence), updated tests.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-medgemma-agentic-grounding/20-RESEARCH.md
@.planning/phases/20-medgemma-agentic-grounding/20-01-SUMMARY.md

Current files being replaced/modified:
@services/grounding-service/src/grounding_service/graph.py
@services/grounding-service/src/grounding_service/nodes/__init__.py
@services/grounding-service/src/grounding_service/nodes/extract_entities.py
@services/grounding-service/src/grounding_service/nodes/ground_to_umls.py
@services/grounding-service/src/grounding_service/nodes/map_to_snomed.py
@services/grounding-service/src/grounding_service/nodes/validate_confidence.py
@services/grounding-service/src/grounding_service/state.py
@services/grounding-service/src/grounding_service/schemas/entities.py
@services/grounding-service/src/grounding_service/prompts/system.jinja2
@services/grounding-service/src/grounding_service/prompts/user.jinja2

UMLS MCP server (tool interface):
@services/umls-mcp-server/src/umls_mcp_server/server.py

Existing MCP result normalization (reuse pattern):
@services/grounding-service/src/grounding_service/nodes/ground_to_umls.py

Existing tests:
@services/grounding-service/tests/test_grounding_graph.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agentic action schemas, prompts, and medgemma_ground node</name>
  <files>
services/grounding-service/src/grounding_service/schemas/agentic_actions.py
services/grounding-service/src/grounding_service/prompts/agentic_system.jinja2
services/grounding-service/src/grounding_service/prompts/agentic_extract.jinja2
services/grounding-service/src/grounding_service/prompts/agentic_evaluate.jinja2
services/grounding-service/src/grounding_service/nodes/medgemma_ground.py
  </files>
  <action>
**Create `schemas/agentic_actions.py`** with Pydantic models for MedGemma's JSON action responses:

```python
class ExtractedEntityAction(BaseModel):
    """An entity extracted by MedGemma with a suggested UMLS search term."""
    text: str  # Exact text from criterion
    entity_type: str  # Condition, Medication, Procedure, Lab_Value, Demographic, Biomarker
    search_term: str  # UMLS search term (may differ from text for better matching)
    span_start: int = 0
    span_end: int = 0
    context_window: str = ""

class GroundingSelection(BaseModel):
    """MedGemma's selection of the best UMLS match for an entity."""
    entity_text: str
    entity_type: str
    selected_cui: str | None = None
    preferred_term: str | None = None
    snomed_code: str | None = None
    confidence: float = 0.0
    reasoning: str = ""  # Why this match was selected

class AgenticAction(BaseModel):
    """MedGemma's structured response in the agentic loop."""
    action_type: Literal["extract", "evaluate", "refine"]
    entities: list[ExtractedEntityAction] = []  # Populated for "extract" and "refine"
    selections: list[GroundingSelection] = []  # Populated for "evaluate"
```

**Create `prompts/agentic_system.jinja2`** — system prompt for MedGemma agentic loop:

The system prompt must:
1. Identify MedGemma as a medical entity grounding agent
2. Define the 6 entity types (Condition, Medication, Procedure, Lab_Value, Demographic, Biomarker)
3. Define the JSON output schema for AgenticAction (action_type, entities, selections)
4. Explain the 3 action types: "extract" (initial entity extraction + search terms), "evaluate" (review UMLS results and select best matches), "refine" (adjust search terms for better matches)
5. Include rules: output ONLY valid JSON (no explanatory text), ensure all JSON is parseable, use entity_type from the 6 allowed types, search_term should be the standard medical term (e.g., "acetaminophen" not "Tylenol"), confidence 0.0-1.0
6. Include 2-3 few-shot examples showing extract action for a sample criterion and evaluate action with UMLS candidates
7. Wrap criterion text in XML tags to prevent prompt injection: `<criterion_text>...</criterion_text>`

**Create `prompts/agentic_extract.jinja2`** — user prompt for initial extraction turn:

```
Extract all medical entities from the following clinical trial eligibility criteria and suggest UMLS search terms for each.

{% for criterion in criteria %}
<criterion id="{{ criterion.id }}" type="{{ criterion.criteria_type }}">
<criterion_text>{{ criterion.text }}</criterion_text>
</criterion>
{% endfor %}

Respond with action_type="extract" and populate the entities array.
```

**Create `prompts/agentic_evaluate.jinja2`** — user prompt for evaluation turn (after UMLS results):

```
Review the UMLS search results below and select the best match for each entity.

{% for result in search_results %}
## Entity: "{{ result.entity_text }}" ({{ result.entity_type }})
Search term: "{{ result.search_term }}"
UMLS candidates:
{% for candidate in result.candidates %}
- CUI: {{ candidate.cui }}, SNOMED: {{ candidate.snomed_code }}, Name: "{{ candidate.display }}", Confidence: {{ candidate.confidence }}
{% endfor %}
{% if not result.candidates %}
- No candidates found
{% endif %}

{% endfor %}

Respond with action_type="evaluate" and populate the selections array. For each entity, select the best matching CUI and SNOMED code. If no good match exists, set selected_cui=null and confidence=0.0.
{% if iteration > 0 %}
This is iteration {{ iteration + 1 }} of {{ max_iterations }}. Previous search terms did not produce satisfactory results. If you want to try different search terms, respond with action_type="refine" instead.
{% endif %}
```

**Create `nodes/medgemma_ground.py`** — the agentic grounding node:

The node implements a programmatic agentic loop (NOT LangChain create_react_agent, since MedGemma doesn't support native tool calling):

```python
async def medgemma_ground_node(state: GroundingState) -> dict[str, Any]:
```

Implementation details:

1. **Load criteria** from database using `_load_criteria_texts()` (copy the function from extract_entities.py — it loads criteria by ID from the DB)

2. **Initialize MedGemma model** via `create_model_loader(AgentConfig.from_env())` from `inference.model_garden`. Cache the model across invocations.

3. **Initialize UMLS MCP client** using the same pattern from `ground_to_umls.py`:
   ```python
   from langchain_mcp_adapters.client import MultiServerMCPClient
   from langchain_mcp_adapters.sessions import StdioConnection
   mcp_config = {
       "umls": StdioConnection(
           command="uv",
           args=["run", "python", "-m", "umls_mcp_server.server"],
           transport="stdio",
       )
   }
   ```
   Get the `concept_search` tool (NOT `concept_linking` — per MGR-03, concept_search returns both CUI and SNOMED).

4. **Agentic loop** (max 3 iterations per criterion batch):

   **Iteration 0 (Extract):**
   - Render `agentic_system.jinja2` + `agentic_extract.jinja2` with criteria
   - Call MedGemma via `model.ainvoke([HumanMessage(content=system+user)])` — NOTE: Gemma has no system role, so fold system prompt into user message. Use `_build_gemma_prompt` indirectly through the model's `_generate()`.
   - Actually, since ModelGardenChatModel._generate() calls _build_gemma_prompt() internally, just pass messages as `[SystemMessage(content=system), HumanMessage(content=user)]` — the _build_gemma_prompt function handles folding system into user turn with `### Instruction:` prefix (all non-AI messages become "user" role).
   - Parse JSON from response (handle markdown fences: strip ```json...``` wrapping)
   - Validate as `AgenticAction` via `model_validate_json()`
   - If action_type=="extract": got entities with search terms, proceed to UMLS search

   **UMLS Search:**
   - For each entity in the extract response, call `concept_search` tool via MCP:
     ```python
     raw_result = await concept_search_tool.ainvoke({"term": entity.search_term, "max_results": 5})
     ```
   - Normalize result using the `_normalize_tool_result()` pattern from `ground_to_umls.py` (handles list-of-content-blocks from langchain-mcp-adapters 0.2.x). The concept_search tool returns a list of dicts, so normalize each block.
   - For concept_search results, the format is a JSON string inside content blocks that is a LIST of candidate dicts (not a single dict like concept_linking). Parse accordingly: the normalized result should be a list of `{"snomed_code": ..., "display": ..., "cui": ..., "ontology": ..., "confidence": ...}`.
   - Collect search results per entity.

   **Iteration 1+ (Evaluate):**
   - Render `agentic_system.jinja2` + `agentic_evaluate.jinja2` with search results, iteration count
   - Call MedGemma, parse response
   - If action_type=="evaluate": MedGemma selected best matches. Build grounded entities from selections.
   - If action_type=="refine": MedGemma wants different search terms. Run UMLS search again with new terms. Increment iteration.
   - If iteration >= max_iterations: force use of best available results.

5. **Build grounded_entities list** from MedGemma's selections:
   ```python
   {
       "criteria_id": criterion["id"],
       "text": selection.entity_text,
       "entity_type": selection.entity_type,
       "span_start": entity_action.span_start,  # From extract phase
       "span_end": entity_action.span_end,
       "context_window": entity_action.context_window,
       "umls_cui": selection.selected_cui,
       "preferred_term": selection.preferred_term,
       "snomed_code": selection.snomed_code,  # Directly from concept_search — MGR-03
       "grounding_confidence": selection.confidence,
       "grounding_method": "agentic_medgemma",
   }
   ```

6. **Fallback handling:**
   - If JSON parsing fails: log warning, fall back to expert_review for that criterion's entities
   - If MCP connection fails: propagate error (same as current ground_to_umls behavior)
   - If concept_search returns empty: entity gets expert_review with confidence 0.0
   - If max iterations reached without evaluate: use best available results, or expert_review

7. **Return** `{"criteria_texts": criteria_texts, "grounded_entities": grounded_entities}`

Key technical decisions:
- Use `concept_search` (NOT `concept_linking`) per MGR-03. concept_search returns both CUI and SNOMED code, making the separate map_to_snomed node redundant.
- Normalize MCP results using `_normalize_tool_result()` pattern from ground_to_umls.py. HOWEVER, concept_search returns a LIST of candidates (not a single dict like concept_linking). So the normalization needs to handle parsing a JSON list from the content block text. Create a `_normalize_search_results()` helper that returns `list[dict]`.
- Apply `@umls_breaker` and retry decorators to the MCP invocation section (wrap the MCP client setup + tool calls).
- Track iteration_history for debugging/telemetry.
  </action>
  <verify>
1. Run `uv run ruff check services/grounding-service/src/grounding_service/schemas/agentic_actions.py services/grounding-service/src/grounding_service/nodes/medgemma_ground.py` — ruff passes
2. Run `uv run python -c "from grounding_service.schemas.agentic_actions import AgenticAction, ExtractedEntityAction, GroundingSelection; print('schemas OK')"` — imports work
3. Run `uv run python -c "from grounding_service.nodes.medgemma_ground import medgemma_ground_node; print('node OK')"` — imports work
4. Verify prompt templates exist: `ls services/grounding-service/src/grounding_service/prompts/agentic_*.jinja2` shows 3 files
  </verify>
  <done>Agentic grounding node, Pydantic action schemas, and 3 Jinja2 prompt templates are created. The node implements a max-3-iteration programmatic loop using MedGemma + UMLS MCP concept_search.</done>
</task>

<task type="auto">
  <name>Task 2: Rewire graph to 2 nodes and update tests</name>
  <files>
services/grounding-service/src/grounding_service/nodes/__init__.py
services/grounding-service/src/grounding_service/graph.py
services/grounding-service/src/grounding_service/state.py
services/grounding-service/tests/test_grounding_graph.py
  </files>
  <action>
**Update `state.py`** — add `iteration_history` field to GroundingState:
```python
class GroundingState(TypedDict):
    batch_id: str
    protocol_id: str
    criteria_ids: list[str]
    criteria_texts: list[dict[str, Any]]
    raw_entities: list[dict[str, Any]]  # Keep for backward compat, unused by new graph
    grounded_entities: list[dict[str, Any]]
    entity_ids: list[str]
    error: str | None
    iteration_history: list[dict[str, Any]]  # NEW: Tracks agentic loop iterations per criterion
```
Update the docstring to reflect the new 2-node graph: `medgemma_ground -> validate_confidence`.

**Update `nodes/__init__.py`** — change exports to new 2-node set:
```python
from .medgemma_ground import medgemma_ground_node
from .validate_confidence import validate_confidence_node

__all__ = [
    "medgemma_ground_node",
    "validate_confidence_node",
]
```
Do NOT delete the old node files (extract_entities.py, ground_to_umls.py, map_to_snomed.py) — they may be useful for reference or rollback. Just remove them from __init__.py exports.

**Rewrite `graph.py`** — simplified 2-node graph:
```python
"""LangGraph workflow definition for the entity grounding agent.

Defines a 2-node StateGraph for the agentic grounding workflow:
START -> medgemma_ground -> validate_confidence -> END

The medgemma_ground node implements an iterative agentic loop where
MedGemma extracts entities, searches UMLS via MCP concept_search,
and evaluates results (max 3 iterations per criterion batch).

Conditional error routing after medgemma_ground:
if state["error"] is set, routes directly to END.
"""

from typing import Any

from langgraph.graph import END, START, StateGraph

from .nodes import medgemma_ground_node, validate_confidence_node
from .state import GroundingState


def should_continue(state: GroundingState) -> str:
    return "error" if state.get("error") else "continue"


def create_graph() -> Any:
    workflow = StateGraph(GroundingState)

    workflow.add_node("medgemma_ground", medgemma_ground_node)
    workflow.add_node("validate_confidence", validate_confidence_node)

    workflow.add_edge(START, "medgemma_ground")
    workflow.add_conditional_edges(
        "medgemma_ground",
        should_continue,
        {"continue": "validate_confidence", "error": END},
    )
    workflow.add_edge("validate_confidence", END)

    return workflow.compile()
```
Keep the `get_graph()` singleton pattern and `_graph` global.

**Update `tests/test_grounding_graph.py`** — update tests for 2-node graph:
- `test_graph_has_two_nodes()` — check that "medgemma_ground" and "validate_confidence" are in node names, and that "extract_entities", "ground_to_umls", "map_to_snomed" are NOT present
- Keep `test_should_continue_*` tests (same behavior)
- Keep `test_get_graph_singleton` test
- Keep `test_create_graph_returns_compiled` test
- Update `os.environ.setdefault("DATABASE_URL", ...)` if still needed
  </action>
  <verify>
1. Run `cd /Users/noahdolevelixir/Code/medgemma-hackathon && uv run pytest services/grounding-service/tests/test_grounding_graph.py -v` — all tests pass
2. Run `uv run ruff check services/grounding-service/src/grounding_service/graph.py services/grounding-service/src/grounding_service/state.py services/grounding-service/src/grounding_service/nodes/__init__.py` — ruff passes
3. Run `uv run python -c "from grounding_service.graph import create_graph; g = create_graph(); nodes = list(g.get_graph().nodes); print(f'Nodes: {nodes}'); assert 'medgemma_ground' in nodes; assert 'validate_confidence' in nodes; print('Graph OK')"` — prints "Graph OK"
  </verify>
  <done>Grounding graph simplified to 2 nodes (medgemma_ground -> validate_confidence). Old nodes removed from exports but files preserved. Tests pass with new graph structure. GroundingState has iteration_history field.</done>
</task>

</tasks>

<verification>
1. Graph compiles and has exactly 2 functional nodes: medgemma_ground, validate_confidence
2. All graph tests pass: `uv run pytest services/grounding-service/tests/test_grounding_graph.py -v`
3. Agentic schemas import cleanly: `uv run python -c "from grounding_service.schemas.agentic_actions import AgenticAction"`
4. Agentic node imports cleanly: `uv run python -c "from grounding_service.nodes.medgemma_ground import medgemma_ground_node"`
5. Prompt templates exist at `services/grounding-service/src/grounding_service/prompts/agentic_{system,extract,evaluate}.jinja2`
6. `uv run ruff check services/grounding-service/` passes clean
7. Graph flow is START -> medgemma_ground -> (error check) -> validate_confidence -> END
8. GroundingState TypedDict includes iteration_history field
</verification>

<success_criteria>
- Agentic grounding node (medgemma_ground.py) implements programmatic loop: MedGemma extract -> UMLS MCP concept_search -> MedGemma evaluate, max 3 iterations
- concept_search used for both CUI and SNOMED mapping (no separate map_to_snomed call) — MGR-03
- Grounding graph simplified from 4 nodes to 2 (medgemma_ground + validate_confidence) — MGR-04
- JSON parsing handles markdown fences from MedGemma output
- Failed entities fall back to expert_review gracefully
- Graph tests pass with new 2-node structure
- Ruff check passes on all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/20-medgemma-agentic-grounding/20-02-SUMMARY.md`
</output>
