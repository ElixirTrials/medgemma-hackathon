---
phase: 36-e2e-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/e2e/__init__.py
  - tests/e2e/conftest.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Running `uv run pytest -m e2e` against a stopped Docker Compose stack prints a skip message for every E2E test and exits with code 0"
    - "Running `uv run pytest -m e2e` against a running Docker Compose stack connects to the real PostgreSQL database and API"
    - "E2E test fixtures provide authenticated HTTP client and direct DB session for verification queries"
    - "Running `uv run pytest` (without -m e2e) does NOT trigger the Docker Compose health check, adding zero overhead to non-e2e test runs"
  artifacts:
    - path: "tests/e2e/__init__.py"
      provides: "E2E test package marker"
    - path: "tests/e2e/conftest.py"
      provides: "Docker Compose detection, skip logic, DB session, auth client fixtures"
      min_lines: 80
    - path: "pyproject.toml"
      provides: "Updated testpaths to include tests/ directory"
  key_links:
    - from: "tests/e2e/conftest.py"
      to: "http://localhost:8000/health"
      via: "httpx GET to detect Docker Compose availability"
      pattern: "localhost:8000/health"
    - from: "tests/e2e/conftest.py"
      to: "postgresql://postgres:postgres@localhost:5432/app"
      via: "SQLModel Session for cleanup and verification"
      pattern: "postgresql.*localhost.*5432"
---

<objective>
Create E2E test conftest with Docker Compose stack detection, automatic skip when stack is unavailable, and core fixtures (authenticated HTTP client, direct DB session).

Purpose: Establish the foundation so any E2E test can be written with `@pytest.mark.e2e` and automatically skip when Docker Compose is not running, without failing the test suite.

Output: `tests/e2e/conftest.py` with Docker Compose detection and core fixtures.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@pyproject.toml
@infra/docker-compose.yml
@services/api-service/tests/conftest.py
@services/api-service/src/api_service/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update pyproject.toml testpaths and create E2E package</name>
  <files>pyproject.toml, tests/e2e/__init__.py</files>
  <action>
1. Create `tests/e2e/__init__.py` as empty file (package marker).

2. In `pyproject.toml` `[tool.pytest.ini_options]`, update `testpaths` to include the root `tests` directory:
   ```
   testpaths = ["services", "libs", "tests"]
   ```
   The `e2e` marker already exists in pyproject.toml — no change needed there.

3. Add `tests/e2e` to `norecursedirs` exclusion list? NO — we WANT pytest to discover tests there. Just ensure `tests` is in testpaths.
  </action>
  <verify>Run `uv run pytest --collect-only -m e2e` — should collect 0 tests (no test files yet) but NOT error about missing paths.</verify>
  <done>pytest discovers the `tests/e2e/` directory without errors and the e2e marker is recognized.</done>
</task>

<task type="auto">
  <name>Task 2: Create E2E conftest with Docker Compose detection and core fixtures</name>
  <files>tests/e2e/conftest.py</files>
  <action>
Create `tests/e2e/conftest.py` with the following fixtures and hooks:

**1. Docker Compose availability detection (`docker_compose_up` session fixture):**
- Try an HTTP GET to `http://localhost:8000/health` with a 3-second timeout using `httpx`.
- If the request succeeds (status 200), the stack is up — return True.
- If the request fails (ConnectionError, timeout), the stack is down — return False.
- This is a session-scoped fixture (checked once per test run).
- Also check PostgreSQL by attempting `sqlalchemy.create_engine("postgresql://...").connect()` with a 3-second timeout. Both API and DB must be reachable.

**2. Auto-skip hook (`pytest_collection_modifyitems`):**
- For every item with the `e2e` marker, if `docker_compose_up` is False, add a `pytest.mark.skip(reason="Docker Compose stack not running (API at localhost:8000 unreachable)")` marker.
- This ensures `uv run pytest -m e2e` exits 0 with skip messages when Docker Compose is down.
- Implementation: Use a module-level `_stack_available` variable set during conftest load (NOT a fixture, since `pytest_collection_modifyitems` runs before fixtures). Detect stack in a helper function called at module level.

Actually, the cleanest approach: use `pytest_configure` to detect and store result, then `pytest_collection_modifyitems` to skip.

**CRITICAL: Guard _check_stack() so it only runs for e2e test invocations.** The `pytest_configure` hook runs for ALL pytest invocations (unit tests, integration tests, etc.). Running the health check adds ~6 seconds of delay to every `uv run pytest` call. Guard it like this:

```python
import httpx
import pytest

_STACK_AVAILABLE: bool | None = None

def _check_stack() -> bool:
    """Check if Docker Compose stack is running."""
    try:
        resp = httpx.get("http://localhost:8000/health", timeout=3.0)
        if resp.status_code != 200:
            return False
    except (httpx.ConnectError, httpx.TimeoutException, Exception):
        return False
    # Also verify DB
    try:
        from sqlalchemy import create_engine, text
        engine = create_engine(
            "postgresql://postgres:postgres@localhost:5432/app",
            connect_args={"connect_timeout": 3},
        )
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        engine.dispose()
    except Exception:
        return False
    return True

def _wants_e2e(config) -> bool:
    """Return True only if the user explicitly requested e2e tests."""
    # Check -m flag for e2e marker expression
    markexpr = config.getoption("-m", default="")
    if markexpr and "e2e" in markexpr:
        return True
    # Check if any explicit test path is under tests/e2e/
    args = config.getoption("file_or_dir", default=[]) or []
    for arg in args:
        if "tests/e2e" in str(arg) or "test_infrastructure" in str(arg):
            return True
    return False

def pytest_configure(config):
    global _STACK_AVAILABLE
    if _wants_e2e(config):
        _STACK_AVAILABLE = _check_stack()
    else:
        # Don't waste time checking — no e2e tests requested
        _STACK_AVAILABLE = False

def pytest_collection_modifyitems(config, items):
    if _STACK_AVAILABLE:
        return
    skip_marker = pytest.mark.skip(
        reason="Docker Compose stack not running (API at localhost:8000 or PostgreSQL at localhost:5432 unreachable)"
    )
    for item in items:
        if "e2e" in item.keywords:
            item.add_marker(skip_marker)
```

**This ensures:** `uv run pytest` (no -m e2e) has ZERO overhead from health checks. Only `uv run pytest -m e2e` or `uv run pytest tests/e2e/` triggers the check.

**3. `e2e_db_session` fixture (function-scoped):**
- Creates a SQLAlchemy engine pointing to `postgresql://postgres:postgres@localhost:5432/app`.
- Use env vars with defaults: `E2E_DATABASE_URL` env var, defaulting to `postgresql://postgres:postgres@localhost:5432/app`.
- Yields a `sqlmodel.Session`.
- Does NOT roll back — E2E tests operate on the real database; cleanup is handled by a separate fixture in Plan 02.

**4. `e2e_api_client` fixture (function-scoped):**
- Returns an `httpx.Client` instance with `base_url="http://localhost:8000"`.
- Includes auth headers. For E2E tests against the real API with Google OAuth, we need to bypass auth or use a test JWT.
- Check how auth works: The API uses `get_current_user` dependency which validates JWTs. For E2E, generate a test JWT using the same secret the API uses.
- Create the JWT with `PyJWT`: `jwt.encode({"sub": "e2e-test-user", "email": "e2e@test.com", "name": "E2E Test"}, secret, algorithm="HS256")`.
- The secret comes from `JWT_SECRET_KEY` env var (default: `"dev-secret-key-change-in-production"`).
- Set `Authorization: Bearer {token}` header on the client.
- Yield the client, close on teardown.

**5. `e2e_api_url` fixture (session-scoped):**
- Returns the base API URL string: `http://localhost:{API_PORT:-8000}`.
- Reads from `E2E_API_URL` env var with default.

All fixtures should have clear docstrings explaining their purpose and usage.
  </action>
  <verify>
1. With Docker Compose STOPPED: `uv run pytest -m e2e -v` should show 0 tests collected (no test files yet) and exit 0.
2. Verify conftest has no import errors: `uv run pytest --collect-only tests/e2e/` should not error.
3. Verify no overhead on non-e2e runs: `uv run pytest --collect-only -m "not e2e" -q` should complete in under 2 seconds (no health check delay).
  </verify>
  <done>
- `tests/e2e/conftest.py` exists with Docker Compose detection, auto-skip hook, `e2e_db_session`, `e2e_api_client`, and `e2e_api_url` fixtures.
- With stack down, any `@pytest.mark.e2e` test would be skipped with a clear message.
- With stack up, fixtures provide authenticated HTTP client and DB session connected to the real Docker Compose services.
- `_check_stack()` is guarded behind `_wants_e2e()` so non-e2e pytest runs have zero overhead.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest --collect-only tests/e2e/` runs without import errors
2. `uv run pytest -m e2e -v` with Docker Compose stopped exits with code 0
3. conftest.py contains: `pytest_collection_modifyitems`, `_wants_e2e`, `e2e_db_session`, `e2e_api_client` fixtures
4. `uv run pytest --collect-only -q` (no e2e flag) completes fast without health check delay
</verification>

<success_criteria>
- pyproject.toml testpaths includes `tests`
- `tests/e2e/conftest.py` detects Docker Compose via health check + DB check
- E2E tests auto-skip when stack is unavailable (exit code 0, not failure)
- Authenticated HTTP client and DB session fixtures are available for E2E tests
- `_check_stack()` only runs when e2e tests are explicitly requested (zero overhead otherwise)
</success_criteria>

<output>
After completion, create `.planning/phases/36-e2e-test-infrastructure/36-01-SUMMARY.md`
</output>
