---
phase: 07-production-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/shared/resilience.py
  - services/api-service/src/api_service/gcs.py
  - services/extraction-service/src/extraction_service/pdf_parser.py
  - services/extraction-service/src/extraction_service/nodes/ingest.py
  - services/extraction-service/src/extraction_service/nodes/extract.py
  - services/grounding-service/src/grounding_service/nodes/ground_to_umls.py
  - services/extraction-service/src/extraction_service/trigger.py
  - services/grounding-service/src/grounding_service/trigger.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "All GCS operations (upload URL, download URL, set metadata) have tenacity retry with exponential backoff and circuit breaker"
    - "PDF fetching from GCS has retry with exponential backoff"
    - "MCP grounding calls have retry with exponential backoff and circuit breaker"
    - "Per-service circuit breakers exist for Gemini, UMLS, GCS, and Vertex AI"
    - "Circuit breaker trips after 3 consecutive failures and recovers after 60 seconds"
    - "Trigger handlers update protocol status to extraction_failed/grounding_failed with error_reason on graph errors"
  artifacts:
    - path: "libs/shared/src/shared/resilience.py"
      provides: "Circuit breakers and retry decorator factory"
      contains: "gemini_breaker"
    - path: "services/api-service/src/api_service/gcs.py"
      provides: "GCS operations with retry and circuit breaker"
      contains: "retry"
    - path: "services/extraction-service/src/extraction_service/pdf_parser.py"
      provides: "PDF fetch with retry"
      contains: "retry"
    - path: "services/grounding-service/src/grounding_service/nodes/ground_to_umls.py"
      provides: "MCP grounding with retry and circuit breaker"
      contains: "retry"
  key_links:
    - from: "services/api-service/src/api_service/gcs.py"
      to: "libs/shared/src/shared/resilience.py"
      via: "gcs_breaker import"
      pattern: "gcs_breaker"
    - from: "services/grounding-service/src/grounding_service/nodes/ground_to_umls.py"
      to: "libs/shared/src/shared/resilience.py"
      via: "umls_breaker import"
      pattern: "umls_breaker"
    - from: "services/extraction-service/src/extraction_service/trigger.py"
      to: "libs/shared/src/shared/models.py"
      via: "Protocol status update on error"
      pattern: "extraction_failed"
---

<objective>
Add tenacity retry decorators and pybreaker circuit breakers to all external service calls (GCS, Gemini/Vertex AI, UMLS MCP), and update trigger handlers to set proper failure statuses with error reasons.

Purpose: Without retry and circuit breaker patterns, any transient external service failure kills the pipeline. This plan makes the pipeline resilient to temporary outages while protecting against cascading failures via per-service circuit breakers.

Output: Shared resilience module with 4 circuit breakers, retry decorators on all external calls, trigger handlers that set failure statuses with human-readable error reasons.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-production-hardening/07-RESEARCH.md
@libs/shared/src/shared/models.py
@services/api-service/src/api_service/gcs.py
@services/extraction-service/src/extraction_service/pdf_parser.py
@services/extraction-service/src/extraction_service/nodes/ingest.py
@services/extraction-service/src/extraction_service/nodes/extract.py
@services/grounding-service/src/grounding_service/nodes/ground_to_umls.py
@services/extraction-service/src/extraction_service/trigger.py
@services/grounding-service/src/grounding_service/trigger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared resilience module with circuit breakers and add retry to external calls</name>
  <files>
    libs/shared/src/shared/resilience.py
    pyproject.toml
    services/api-service/src/api_service/gcs.py
    services/extraction-service/src/extraction_service/pdf_parser.py
    services/grounding-service/src/grounding_service/nodes/ground_to_umls.py
  </files>
  <action>
  **1. Add pybreaker dependency:**
  Add `"pybreaker>=1.2.0"` to the root `pyproject.toml` dependencies list. Run `uv lock` after.

  **2. Create `libs/shared/src/shared/resilience.py`:**

  This module provides per-service circuit breakers (per CONTEXT.md: "Per-service independent circuit breakers") and a retry decorator factory.

  ```python
  """Shared resilience patterns: circuit breakers and retry helpers.

  Per-service circuit breakers for GCS, Gemini, UMLS MCP, and Vertex AI.
  Each breaker trips after 3 consecutive failures (per CONTEXT.md decision)
  and recovers after 60 seconds (Claude's discretion).
  """

  import logging

  from pybreaker import CircuitBreaker

  logger = logging.getLogger(__name__)

  # Recovery timeout: 60 seconds per research recommendation
  _RECOVERY_TIMEOUT = 60
  # Failure threshold: 3 consecutive failures per CONTEXT.md decision
  _FAIL_MAX = 3

  gemini_breaker = CircuitBreaker(
      fail_max=_FAIL_MAX,
      timeout_duration=_RECOVERY_TIMEOUT,
      name="gemini",
  )

  umls_breaker = CircuitBreaker(
      fail_max=_FAIL_MAX,
      timeout_duration=_RECOVERY_TIMEOUT,
      name="umls",
  )

  gcs_breaker = CircuitBreaker(
      fail_max=_FAIL_MAX,
      timeout_duration=_RECOVERY_TIMEOUT,
      name="gcs",
  )

  vertex_ai_breaker = CircuitBreaker(
      fail_max=_FAIL_MAX,
      timeout_duration=_RECOVERY_TIMEOUT,
      name="vertex_ai",
  )
  ```

  **3. Add retry + circuit breaker to GCS operations (`gcs.py`):**

  Add imports at top:
  ```python
  from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_random_exponential, before_sleep_log
  from shared.resilience import gcs_breaker
  ```

  Wrap `generate_upload_url`, `set_blob_metadata`, and `generate_download_url` with:
  - `@gcs_breaker` as the OUTER decorator (circuit breaker outside retry)
  - `@retry(retry=retry_if_exception_type(Exception), stop=stop_after_attempt(3), wait=wait_random_exponential(multiplier=1, min=2, max=10), before_sleep=before_sleep_log(logger, logging.WARNING), reraise=True)` as the INNER decorator

  Important: Do NOT retry `ValueError` (configuration errors). Only retry actual GCS API errors. Use `retry_if_exception_type(Exception)` but exclude ValueError by adding a custom retry condition:
  ```python
  from tenacity import retry_if_not_exception_type

  # Combine: retry on any exception EXCEPT ValueError
  _gcs_retry = retry(
      retry=(retry_if_exception_type(Exception) & retry_if_not_exception_type(ValueError)),
      stop=stop_after_attempt(3),
      wait=wait_random_exponential(multiplier=1, min=2, max=10),
      before_sleep=before_sleep_log(logger, logging.WARNING),
      reraise=True,
  )
  ```
  Then apply `@gcs_breaker` and `@_gcs_retry` to the three GCS functions.

  **4. Add retry to PDF fetching (`pdf_parser.py`):**

  Only the GCS branch of `fetch_pdf_bytes` needs retry. Wrap just the GCS download portion:

  Add imports:
  ```python
  from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_random_exponential, before_sleep_log
  from shared.resilience import gcs_breaker
  ```

  Extract GCS download to a helper function decorated with retry + circuit breaker:
  ```python
  @gcs_breaker
  @retry(
      retry=retry_if_exception_type(Exception),
      stop=stop_after_attempt(3),
      wait=wait_random_exponential(multiplier=1, min=2, max=10),
      before_sleep=before_sleep_log(logger, logging.WARNING),
      reraise=True,
  )
  def _download_from_gcs(bucket_name: str, blob_name: str) -> bytes:
      from google.cloud import storage
      client = storage.Client()
      bucket = client.bucket(bucket_name)
      blob = bucket.blob(blob_name)
      return blob.download_as_bytes()
  ```
  Then call `_download_from_gcs(bucket_name, blob_name)` from the gs:// branch.

  **5. Add retry + circuit breaker to MCP grounding (`ground_to_umls.py`):**

  Add imports:
  ```python
  from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_random_exponential, before_sleep_log
  from shared.resilience import umls_breaker
  ```

  Wrap the `_ground_via_mcp` function with retry + circuit breaker:
  ```python
  @umls_breaker
  @retry(
      retry=retry_if_exception_type((RuntimeError, ConnectionError, OSError)),
      stop=stop_after_attempt(3),
      wait=wait_random_exponential(multiplier=1, min=4, max=10),
      before_sleep=before_sleep_log(logger, logging.WARNING),
      reraise=True,
  )
  async def _ground_via_mcp(entities):
      ...
  ```
  Note: Use min=4 for UMLS (slower service recovery). Retry on RuntimeError (MCP connection failure), ConnectionError, and OSError (subprocess issues).
  </action>
  <verify>
  `uv run python -c "from shared.resilience import gemini_breaker, umls_breaker, gcs_breaker, vertex_ai_breaker; print('OK')"` prints OK.
  `uv run ruff check libs/shared/src/shared/resilience.py services/api-service/src/api_service/gcs.py services/extraction-service/src/extraction_service/pdf_parser.py services/grounding-service/src/grounding_service/nodes/ground_to_umls.py` passes.
  `uv run mypy libs/shared/src/shared/resilience.py` passes.
  </verify>
  <done>
  4 per-service circuit breakers exist (gemini, umls, gcs, vertex_ai) with fail_max=3 and 60s recovery. GCS operations have retry + circuit breaker. PDF GCS download has retry + circuit breaker. MCP grounding has retry + circuit breaker.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update trigger handlers to set failure statuses with error reasons</name>
  <files>
    services/extraction-service/src/extraction_service/trigger.py
    services/grounding-service/src/grounding_service/trigger.py
  </files>
  <action>
  The trigger handlers currently just log and re-raise on failure. They need to update the protocol's status to a failure category with a human-readable error_reason before re-raising (per CONTEXT.md: "Three distinct failure categories: Upload/parse failed, Extraction failed, Grounding failed").

  **In `services/extraction-service/src/extraction_service/trigger.py`:**

  1. Add imports:
     ```python
     from api_service.storage import engine
     from shared.models import Protocol
     from sqlmodel import Session
     ```

  2. In the `except Exception` block, before `raise`, add protocol status update:
     ```python
     except Exception as e:
         logger.exception(
             "Extraction workflow failed for protocol %s",
             protocol_id,
         )
         # Update protocol status with failure category
         try:
             with Session(engine) as session:
                 protocol = session.get(Protocol, protocol_id)
                 if protocol:
                     protocol.status = "extraction_failed"
                     protocol.error_reason = _categorize_extraction_error(e)
                     protocol.metadata_ = {
                         **protocol.metadata_,
                         "error": {
                             "category": "extraction_failed",
                             "reason": protocol.error_reason,
                             "exception_type": type(e).__name__,
                         },
                     }
                     session.add(protocol)
                     session.commit()
         except Exception:
             logger.exception("Failed to update protocol status for %s", protocol_id)
         raise
     ```

  3. Add helper function `_categorize_extraction_error(e: Exception) -> str`:
     ```python
     def _categorize_extraction_error(e: Exception) -> str:
         """Convert exception to human-readable error reason."""
         error_str = str(e).lower()
         if "pdf" in error_str or "parse" in error_str or "pymupdf" in error_str:
             return "PDF text quality too low or file corrupted"
         if "circuit" in error_str:
             return "AI service temporarily unavailable"
         if "timeout" in error_str or "timed out" in error_str:
             return "Processing timed out"
         if "credential" in error_str or "auth" in error_str:
             return "Service authentication failed"
         if "gcs" in error_str or "storage" in error_str or "bucket" in error_str:
             return "File storage service unavailable"
         return f"Extraction failed: {type(e).__name__}"
     ```

  **In `services/grounding-service/src/grounding_service/trigger.py`:**

  4. Same pattern: Add imports for engine, Protocol, Session.

  5. In the `except Exception` block, before `raise`, update protocol status:
     ```python
     except Exception as e:
         logger.exception(
             "Grounding workflow failed for batch %s",
             batch_id,
         )
         # Update protocol status with failure category
         protocol_id = payload.get("protocol_id")
         if protocol_id:
             try:
                 with Session(engine) as session:
                     protocol = session.get(Protocol, protocol_id)
                     if protocol:
                         protocol.status = "grounding_failed"
                         protocol.error_reason = _categorize_grounding_error(e)
                         protocol.metadata_ = {
                             **protocol.metadata_,
                             "error": {
                                 "category": "grounding_failed",
                                 "reason": protocol.error_reason,
                                 "exception_type": type(e).__name__,
                             },
                         }
                         session.add(protocol)
                         session.commit()
             except Exception:
                 logger.exception("Failed to update protocol status for %s", protocol_id)
         raise
     ```

  6. Add helper `_categorize_grounding_error(e: Exception) -> str`:
     ```python
     def _categorize_grounding_error(e: Exception) -> str:
         """Convert exception to human-readable error reason."""
         error_str = str(e).lower()
         if "mcp" in error_str or "subprocess" in error_str:
             return "UMLS grounding service unavailable"
         if "circuit" in error_str:
             return "UMLS service temporarily unavailable"
         if "timeout" in error_str:
             return "Grounding timed out"
         if "concept_linking" in error_str:
             return "UMLS concept linking tool unavailable"
         return f"Grounding failed: {type(e).__name__}"
     ```
  </action>
  <verify>
  `uv run ruff check services/extraction-service/src/extraction_service/trigger.py services/grounding-service/src/grounding_service/trigger.py` passes.
  `uv run mypy services/extraction-service/src/extraction_service/trigger.py services/grounding-service/src/grounding_service/trigger.py` passes (allowing existing exclusions).
  `uv run pytest -x` passes (existing tests still work).
  </verify>
  <done>
  Extraction trigger sets protocol status to "extraction_failed" with categorized error_reason on failure. Grounding trigger sets protocol status to "grounding_failed" with categorized error_reason on failure. Both store error metadata in protocol.metadata_["error"]. Error categories are human-readable per CONTEXT.md decision.
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check .` passes
2. `uv run mypy .` passes (allowing existing exclusions)
3. `uv run pytest` passes
4. pybreaker is installed: `uv run python -c "import pybreaker; print(pybreaker.__version__)"`
5. 4 circuit breakers importable from shared.resilience
6. GCS functions have retry + circuit breaker decorators
7. PDF GCS download has retry + circuit breaker
8. MCP grounding has retry + circuit breaker
9. Extraction trigger sets extraction_failed status on error
10. Grounding trigger sets grounding_failed status on error
</verification>

<success_criteria>
- pybreaker installed in workspace
- 4 per-service circuit breakers (gemini, umls, gcs, vertex_ai) with fail_max=3, 60s recovery
- GCS operations wrapped with retry (3 attempts, exponential backoff with jitter, 2-10s range) and gcs_breaker
- PDF GCS download wrapped with retry + gcs_breaker
- MCP grounding wrapped with retry (3 attempts, 4-10s range) + umls_breaker
- Extraction trigger updates protocol to extraction_failed with human-readable error_reason
- Grounding trigger updates protocol to grounding_failed with human-readable error_reason
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-hardening/07-02-SUMMARY.md`
</output>
