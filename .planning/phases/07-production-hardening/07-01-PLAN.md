---
phase: 07-production-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/shared/models.py
  - libs/events-py/src/events_py/outbox.py
  - services/api-service/src/api_service/protocols.py
  - services/api-service/alembic/versions/07_01_protocol_status_enum.py
autonomous: true

must_haves:
  truths:
    - "Protocol.status uses a ProtocolStatus enum with 9 values including dead_letter and archived"
    - "Outbox processor stops retrying after 3 failures and marks protocol as dead_letter with error metadata"
    - "POST /protocols/{id}/retry resets failed/dead-letter protocols to uploaded and creates a new outbox event"
    - "Dead-letter protocols older than 7 days are archived when their status is next checked"
  artifacts:
    - path: "libs/shared/src/shared/models.py"
      provides: "ProtocolStatus enum and error metadata pattern"
      contains: "class ProtocolStatus"
    - path: "libs/events-py/src/events_py/outbox.py"
      provides: "Max retry detection and dead-letter transition"
      contains: "MAX_RETRIES"
    - path: "services/api-service/src/api_service/protocols.py"
      provides: "POST retry endpoint for failed protocols"
      contains: "retry"
  key_links:
    - from: "libs/events-py/src/events_py/outbox.py"
      to: "libs/shared/src/shared/models.py"
      via: "ProtocolStatus enum import for dead_letter transition"
      pattern: "ProtocolStatus"
    - from: "services/api-service/src/api_service/protocols.py"
      to: "libs/events-py/src/events_py/outbox.py"
      via: "persist_with_outbox for retry event creation"
      pattern: "persist_with_outbox"
---

<objective>
Add protocol status state machine with ProtocolStatus enum, dead-letter handling in the outbox processor, manual retry endpoint, and 7-day dead-letter archival.

Purpose: Without a proper status enum and dead-letter handling, the pipeline has no way to distinguish failure categories, cap retries, or let users retry failed protocols. This is the foundation for all other Phase 7 work.

Output: ProtocolStatus enum in shared models, outbox processor with max retry + dead-letter transition, POST retry endpoint, Alembic migration for status values.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-production-hardening/07-RESEARCH.md
@libs/shared/src/shared/models.py
@libs/events-py/src/events_py/outbox.py
@services/api-service/src/api_service/protocols.py
@services/extraction-service/src/extraction_service/trigger.py
@services/grounding-service/src/grounding_service/trigger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ProtocolStatus enum and update Protocol model with error metadata</name>
  <files>
    libs/shared/src/shared/models.py
    services/api-service/alembic/versions/07_01_protocol_status_enum.py
  </files>
  <action>
  In `libs/shared/src/shared/models.py`:

  1. Add `ProtocolStatus(str, Enum)` with these values (per CONTEXT.md decisions):
     - UPLOADED = "uploaded"
     - EXTRACTING = "extracting"
     - EXTRACTION_FAILED = "extraction_failed"
     - GROUNDING = "grounding"
     - GROUNDING_FAILED = "grounding_failed"
     - PENDING_REVIEW = "pending_review"
     - COMPLETE = "complete"
     - DEAD_LETTER = "dead_letter"
     - ARCHIVED = "archived"

  2. Update `Protocol.status` field: Change default from `"uploaded"` to `ProtocolStatus.UPLOADED`. Keep it as `str` in the database (no PostgreSQL enum type -- string with application-level enum validation). Keep the `index=True`.

  3. Add an `error_reason` field to Protocol: `error_reason: str | None = Field(default=None)`. This stores the human-readable error reason per CONTEXT.md decision (e.g., "PDF text quality too low", "AI service unavailable"). Keep technical details in `metadata_["error"]` dict.

  4. Create Alembic migration that adds the `error_reason` column to the protocols table. Use `op.add_column('protocol', sa.Column('error_reason', sa.String(), nullable=True))`. Do NOT convert the status column to a PostgreSQL enum type -- keep it as string.

  Important: Import `from enum import Enum` at the top of models.py.
  </action>
  <verify>
  `uv run python -c "from shared.models import ProtocolStatus; print(list(ProtocolStatus))"` prints all 9 enum values.
  `uv run python -c "from shared.models import Protocol; p = Protocol(title='t', file_uri='gs://b/p'); print(p.status)"` prints `uploaded`.
  `uv run alembic upgrade head` applies the migration cleanly (run from services/api-service directory).
  </verify>
  <done>
  ProtocolStatus enum exists with 9 values. Protocol.status defaults to ProtocolStatus.UPLOADED. Protocol has error_reason field. Alembic migration adds error_reason column.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add dead-letter handling to outbox processor and retry endpoint</name>
  <files>
    libs/events-py/src/events_py/outbox.py
    services/api-service/src/api_service/protocols.py
  </files>
  <action>
  **In `libs/events-py/src/events_py/outbox.py`:**

  1. Add `MAX_RETRIES = 3` constant at module level.

  2. In `poll_and_process`, in the `except Exception` block, after incrementing `event.retry_count`, add dead-letter detection:
     ```python
     if event.retry_count >= MAX_RETRIES:
         event.status = "dead_letter"
         logger.warning(
             "Event %s exhausted retries (%d), marking as dead_letter",
             event.id, event.retry_count,
         )
         # Update protocol status to dead_letter if this is a protocol event
         if event.aggregate_type == "protocol":
             from shared.models import Protocol
             protocol = session.get(Protocol, event.aggregate_id)
             if protocol:
                 protocol.status = "dead_letter"
                 protocol.error_reason = "Maximum retries exceeded"
                 protocol.metadata_ = {
                     **protocol.metadata_,
                     "error": {
                         "category": "pipeline_failed",
                         "reason": "Maximum retries exceeded",
                         "retry_count": event.retry_count,
                     },
                 }
                 session.add(protocol)
     else:
         event.status = "failed"
         event.retry_count += 1
     ```
     Note: Move the existing `event.retry_count += 1` into the else branch. The `event.status = "failed"` in the existing code should also move into the else.

  3. Also update the poll query to include "failed" events that haven't exceeded max retries: change `.where(OutboxEvent.status == "pending")` to `.where(OutboxEvent.status.in_(["pending", "failed"]))` so failed events get re-polled for retry.

  **In `services/api-service/src/api_service/protocols.py`:**

  4. Add a retry endpoint:
     ```python
     @router.post("/{protocol_id}/retry")
     def retry_protocol(
         protocol_id: str,
         db: Session = Depends(get_db),
     ):
     ```
     - Fetch protocol by ID, 404 if not found.
     - Validate `protocol.status in ("extraction_failed", "grounding_failed", "dead_letter")`. If not, return 400 "Protocol is not in a retryable state".
     - Reset `protocol.status = "uploaded"`, `protocol.error_reason = None`, clear `protocol.metadata_["error"]` if present.
     - Call `persist_with_outbox` to create a new `PROTOCOL_UPLOADED` event (re-triggers the pipeline).
     - Commit and return `{"status": "retry_queued", "protocol_id": protocol_id}`.

  5. Add dead-letter archival check: Create a helper `_check_dead_letter_archival(protocol, session)` that checks if a dead-letter protocol's `updated_at` is more than 7 days ago. If so, change status to "archived". Call this from the `get_protocol` detail endpoint (lazy archival per research recommendation Option B).

  6. Update the `list_protocols` endpoint to exclude "archived" protocols from the default view. When `status` query param is None, add `.where(Protocol.status != "archived")`.
  </action>
  <verify>
  `uv run ruff check libs/events-py/src/events_py/outbox.py services/api-service/src/api_service/protocols.py` passes clean.
  `uv run mypy libs/events-py/src/events_py/outbox.py services/api-service/src/api_service/protocols.py` passes clean.
  `uv run pytest services/api-service/tests/ -x` passes (existing tests still work).
  </verify>
  <done>
  Outbox processor detects retry exhaustion at 3 retries and transitions protocol to dead_letter with error metadata. Failed events are re-polled for retry. POST /protocols/{id}/retry endpoint resets failed protocols and re-queues them. Archived protocols hidden from default list view. Dead-letter archival triggers on detail view access after 7 days.
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check .` passes
2. `uv run mypy .` passes (allowing existing exclusions)
3. `uv run pytest` passes -- existing tests still work
4. ProtocolStatus enum is importable and has 9 values
5. Protocol model has error_reason field
6. Outbox processor has MAX_RETRIES = 3 and dead-letter logic
7. POST /protocols/{id}/retry endpoint exists and returns 200 for failed protocols
</verification>

<success_criteria>
- ProtocolStatus enum with 9 values exists in shared models
- Protocol model uses enum default and has error_reason field
- Outbox processor caps retries at 3 and sets dead_letter status
- Failed outbox events are re-polled for retry
- Retry endpoint resets protocol status and creates new outbox event
- Dead-letter protocols auto-archive after 7 days on access
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-hardening/07-01-SUMMARY.md`
</output>
