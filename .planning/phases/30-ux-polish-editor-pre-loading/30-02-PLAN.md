---
phase: 30-ux-polish-editor-pre-loading
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - apps/hitl-ui/src/components/RejectDialog.tsx
  - apps/hitl-ui/src/components/CriterionCard.tsx
  - apps/hitl-ui/src/components/FieldMappingBadges.tsx
  - apps/hitl-ui/src/hooks/useReviews.ts
autonomous: true

must_haves:
  truths:
    - "Clicking Reject opens a dialog with predefined reason checkboxes (multi-select) plus optional free-text comment"
    - "Reject reasons include: 'Not a criteria', 'Incorrect entity grounding', 'Poor splitting into composites'"
    - "Reject dialog submits reasons and optional comment via the existing review action API"
    - "Saved field_mappings display as clickable mini-cards in read mode showing entity/relation/value"
    - "Field mapping mini-cards show entity/relation/value rows with AND/OR connector between them"
    - "Clicking any field mapping mini-card opens the structured editor with all saved mappings loaded"
    - "Approve remains one-click with no rationale prompt per user decision"
  artifacts:
    - path: "apps/hitl-ui/src/components/RejectDialog.tsx"
      provides: "Reject reason dialog with multi-select checkboxes, optional free-text, and submit/cancel"
    - path: "apps/hitl-ui/src/components/FieldMappingBadges.tsx"
      provides: "Read-mode display of saved field_mappings as clickable mini-cards with AND/OR connectors"
    - path: "apps/hitl-ui/src/components/CriterionCard.tsx"
      provides: "Integration of RejectDialog and FieldMappingBadges into the card"
  key_links:
    - from: "apps/hitl-ui/src/components/RejectDialog.tsx"
      to: "apps/hitl-ui/src/components/CriterionCard.tsx"
      via: "RejectDialog onConfirm callback triggers onAction with reject + reasons"
      pattern: "onConfirm.*reasons"
    - from: "apps/hitl-ui/src/components/FieldMappingBadges.tsx"
      to: "apps/hitl-ui/src/components/CriterionCard.tsx"
      via: "FieldMappingBadges onEditClick callback triggers setEditMode('structured')"
      pattern: "setEditMode.*structured"
---

<objective>
Add reject reason dialog with predefined checkboxes and field mapping read-mode badges with AND/OR connectors to the CriterionCard.

Purpose: Reviewers need structured reject reasons for audit compliance. Saved field mappings need to be visible in read mode so reviewers can see what's been captured without entering edit mode.
Output: RejectDialog.tsx component, FieldMappingBadges.tsx component, updated CriterionCard.tsx integrating both.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-ux-polish-editor-pre-loading/30-CONTEXT.md
@.planning/phases/30-ux-polish-editor-pre-loading/30-RESEARCH.md
@.planning/phases/30-ux-polish-editor-pre-loading/30-01-SUMMARY.md
@apps/hitl-ui/src/components/CriterionCard.tsx
@apps/hitl-ui/src/hooks/useReviews.ts
@apps/hitl-ui/src/components/structured-editor/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RejectDialog component and CriterionCard reject integration</name>
  <files>apps/hitl-ui/src/components/RejectDialog.tsx, apps/hitl-ui/src/components/CriterionCard.tsx, apps/hitl-ui/src/hooks/useReviews.ts</files>
  <action>
1. **Create `apps/hitl-ui/src/components/RejectDialog.tsx`:**

   A Radix Dialog component with react-hook-form for reject reason capture.

   Props interface:
   ```typescript
   interface RejectDialogProps {
     open: boolean;
     onOpenChange: (open: boolean) => void;
     onConfirm: (data: { reasons: string[]; comment?: string }) => void;
   }
   ```

   Predefined reject reasons (per user decision):
   ```typescript
   const REJECT_REASONS = [
     { value: 'not_criteria', label: 'Not a criteria' },
     { value: 'incorrect_grounding', label: 'Incorrect entity grounding' },
     { value: 'poor_splitting', label: 'Poor splitting into composites' },
     { value: 'duplicate', label: 'Duplicate of another criterion' },
     { value: 'other', label: 'Other' },
   ];
   ```

   Implementation:
   - Use `@radix-ui/react-dialog` (already installed) for Dialog.Root, Dialog.Portal, Dialog.Overlay, Dialog.Content, Dialog.Title
   - Use react-hook-form `useForm` + `Controller` for checkbox group state management
   - Checkbox group: each REJECT_REASONS item renders as a labeled checkbox; Controller manages the `reasons: string[]` array
   - Optional free-text textarea for additional comments (Controller for `comment: string`)
   - Submit button (red/destructive variant) calls `onConfirm({ reasons, comment })`, then resets form and closes dialog
   - Cancel button resets form and closes dialog
   - Dialog overlay: `fixed inset-0 bg-black/50 z-50`
   - Dialog content: `fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white dark:bg-card rounded-lg p-6 max-w-md w-full z-50 shadow-lg`
   - Use existing Button component from `../ui/Button`

2. **Update `apps/hitl-ui/src/hooks/useReviews.ts`:**

   Extend `ReviewActionRequest` to include reject_reasons:
   ```typescript
   export interface ReviewActionRequest {
     action: 'approve' | 'reject' | 'modify';
     reviewer_id: string;
     modified_text?: string;
     modified_type?: string;
     modified_category?: string;
     modified_structured_fields?: {
       field_mappings?: FieldMapping[];
       [key: string]: unknown;
     };
     comment?: string;
     reject_reasons?: string[];  // NEW: predefined reject reason codes
   }
   ```

3. **Update `apps/hitl-ui/src/components/CriterionCard.tsx`:**

   a. Add import: `import RejectDialog from './RejectDialog';`

   b. Add state for reject dialog: `const [rejectDialogOpen, setRejectDialogOpen] = useState(false);`

   c. Replace `handleReject()` function:
   ```typescript
   function handleReject() {
     setRejectDialogOpen(true);
   }

   function handleRejectConfirm(data: { reasons: string[]; comment?: string }) {
     onAction(criterion.id, {
       action: 'reject',
       reviewer_id: 'current-user',
       reject_reasons: data.reasons,
       comment: data.comment,
     });
   }
   ```

   d. Add the RejectDialog component at the end of the CriterionCard return, just before the closing `</div>`:
   ```tsx
   <RejectDialog
     open={rejectDialogOpen}
     onOpenChange={setRejectDialogOpen}
     onConfirm={handleRejectConfirm}
   />
   ```

   **Note:** Approve remains one click — no dialog, no rationale prompt per user decision. The existing `handleApprove()` function stays unchanged.
  </action>
  <verify>
1. Run `cd /Users/noahdolevelixir/Code/medgemma-hackathon/apps/hitl-ui && npx tsc --noEmit` — zero TypeScript errors.
2. Verify RejectDialog imports Radix Dialog correctly.
3. Verify CriterionCard handleApprove is unchanged (one-click, no dialog).
4. Verify reject_reasons field added to ReviewActionRequest.
  </verify>
  <done>Clicking Reject opens a dialog with predefined reason checkboxes (multi-select) plus optional free-text comment. Submitting the dialog fires the reject action with reasons and comment. Approve remains one-click.</done>
</task>

<task type="auto">
  <name>Task 2: Field mapping read-mode badges with AND/OR connectors</name>
  <files>apps/hitl-ui/src/components/FieldMappingBadges.tsx, apps/hitl-ui/src/components/CriterionCard.tsx</files>
  <action>
1. **Create `apps/hitl-ui/src/components/FieldMappingBadges.tsx`:**

   A component that displays saved field_mappings as structured mini-cards in read mode.

   Props:
   ```typescript
   interface FieldMappingBadgesProps {
     criterion: Criterion;
     onEditClick: () => void;
   }
   ```

   Implementation:
   - Extract `field_mappings` from `criterion.conditions` (same pattern as buildInitialValues):
     ```typescript
     const cond = criterion.conditions as Record<string, unknown> | null;
     const fieldMappings = (cond && 'field_mappings' in cond && Array.isArray(cond.field_mappings))
       ? cond.field_mappings as Array<{ entity: string; relation: string; value: Record<string, unknown> }>
       : null;
     ```
   - If no field_mappings or empty array, return null (don't render anything).

   - Render each mapping as a row-style mini-card (not pill badges — per user decision, these should be entity/relation/value rows with composite connectors):
     ```tsx
     <div className="mb-3">
       <div className="text-xs font-medium text-muted-foreground mb-2">Field Mappings</div>
       <div className="space-y-1">
         {fieldMappings.map((mapping, idx) => (
           <div key={idx}>
             {idx > 0 && (
               <div className="flex items-center gap-2 py-1">
                 <span className="text-xs font-semibold text-purple-600 bg-purple-50 px-2 py-0.5 rounded">
                   AND
                 </span>
                 <div className="flex-1 border-t border-dashed border-muted" />
               </div>
             )}
             <button
               onClick={onEditClick}
               className="w-full text-left flex items-center gap-2 rounded-md border bg-blue-50/50 border-blue-200 px-3 py-2 text-sm hover:bg-blue-100/50 transition-colors cursor-pointer"
               title="Click to edit field mappings"
             >
               <span className="font-semibold text-blue-900">{mapping.entity || '—'}</span>
               {mapping.relation && (
                 <>
                   <span className="text-blue-600 font-mono text-xs">{mapping.relation}</span>
                   <span className="text-blue-800">{formatMappingValue(mapping.value)}</span>
                 </>
               )}
             </button>
           </div>
         ))}
       </div>
     </div>
     ```

   - `formatMappingValue` helper function (same as in research):
     ```typescript
     function formatMappingValue(value: Record<string, unknown>): string {
       if (typeof value !== 'object' || value === null) return '';
       if (value.type === 'range') return `${value.min}–${value.max}${value.unit ? ' ' + value.unit : ''}`;
       if (value.type === 'temporal') return `${value.duration} ${value.unit}`;
       if (value.type === 'standard') return `${value.value}${value.unit ? ' ' + value.unit : ''}`;
       return '';
     }
     ```

   - The AND connector is the default. Per user decision, connectors should be "modifiable composite connector (AND/OR)". For read mode, display AND as the default static connector. The actual editable AND/OR logic is part of the structured editor (already handles multiple mappings via useFieldArray).

   - Import `Criterion` type from `../hooks/useReviews`.

2. **Update `apps/hitl-ui/src/components/CriterionCard.tsx`:**

   a. Add import: `import FieldMappingBadges from './FieldMappingBadges';`

   b. In the read-mode section (where `editMode === 'none'`), add FieldMappingBadges AFTER the criterion text paragraph and BEFORE the assertion status / temporal constraint / threshold displays. Specifically, insert after the closing `</p>` of the criterion text and before the assertion status `{criterion.assertion_status && ...}`:

   ```tsx
   {/* Field mapping badges (read mode) */}
   {editMode === 'none' && (
     <FieldMappingBadges
       criterion={criterion}
       onEditClick={() => setEditMode('structured')}
     />
   )}
   ```

   Wait — the `editMode === 'none'` condition is already the outer branch. The FieldMappingBadges should be placed right after the criterion text `<p>` element within the else branch for `editMode === 'none'`. Looking at the code structure:

   The body section has:
   - `editMode === 'text'` -> text editor
   - `editMode === 'structured'` -> structured editor
   - else (editMode === 'none') -> criterion text paragraph

   After the criterion text paragraph (which is the else branch ending at line ~504), add the FieldMappingBadges component. It should be placed between the closing of the text paragraph conditional block and the assertion status block:

   ```tsx
   {/* After the criterion text / editors conditional block */}

   {/* Field mapping badges - shown in read mode only */}
   {editMode === 'none' && (
     <FieldMappingBadges
       criterion={criterion}
       onEditClick={() => setEditMode('structured')}
     />
   )}

   {/* Assertion status tag (existing) */}
   ```

   This ensures badges appear in read mode, between the text and the metadata displays.
  </action>
  <verify>
1. Run `cd /Users/noahdolevelixir/Code/medgemma-hackathon/apps/hitl-ui && npx tsc --noEmit` — zero TypeScript errors.
2. Run `cd /Users/noahdolevelixir/Code/medgemma-hackathon/apps/hitl-ui && npx biome check src/components/FieldMappingBadges.tsx src/components/RejectDialog.tsx` — zero lint errors.
3. Verify FieldMappingBadges returns null when no field_mappings exist (no empty state rendered).
4. Verify clicking a badge calls `onEditClick` which sets editMode to 'structured'.
  </verify>
  <done>Saved field_mappings display as clickable mini-card rows in read mode with AND connector between them. Each row shows entity/relation/value. Clicking any row opens the structured editor with all saved mappings pre-loaded (via existing buildInitialValues which already handles field_mappings priority).</done>
</task>

<task type="auto">
  <name>Task 3: Verify EDIT-01 — editor pre-loading from saved field_mappings</name>
  <files>apps/hitl-ui/src/components/CriterionCard.tsx</files>
  <action>
Verify that the existing `buildInitialValues` function in CriterionCard.tsx correctly pre-loads saved field_mappings when entering modify mode (EDIT-01 requirement).

1. Read CriterionCard.tsx and locate `buildInitialValues` function (approximately lines 186-222).
2. Confirm it checks `criterion.conditions.field_mappings` and maps them to StructuredFieldFormValues.
3. Confirm it prioritizes field_mappings over legacy fields when both exist.
4. If buildInitialValues does NOT correctly handle field_mappings:
   - Fix the function to extract field_mappings from criterion.conditions
   - Map each field_mapping to the StructuredFieldFormValues shape expected by the editor
   - Ensure all saved mappings populate the useFieldArray on editor open
5. Manual verification: create a test criterion with saved field_mappings in conditions, click to enter structured edit mode, confirm editor loads all mappings.
  </action>
  <verify>
1. Run `cd /Users/noahdolevelixir/Code/medgemma-hackathon/apps/hitl-ui && npx tsc --noEmit` — zero TypeScript errors.
2. Confirm buildInitialValues reads from criterion.conditions.field_mappings.
3. Confirm editor fields are populated when opening structured editor on a criterion with saved field_mappings.
  </verify>
  <done>buildInitialValues correctly pre-loads saved field_mappings into the structured editor. EDIT-01 requirement verified and working.</done>
</task>

</tasks>

<verification>
1. `cd /Users/noahdolevelixir/Code/medgemma-hackathon/apps/hitl-ui && npx tsc --noEmit` — zero errors
2. `cd /Users/noahdolevelixir/Code/medgemma-hackathon/apps/hitl-ui && npx biome check src/` — zero errors
3. RejectDialog renders with predefined reason checkboxes when clicking Reject button
4. Field mapping badges render for criteria with saved field_mappings in conditions
5. Clicking badges opens structured editor with pre-loaded mappings
6. Approve button remains one-click with no dialog
</verification>

<success_criteria>
- Reject button opens dialog with multi-select checkboxes for predefined reasons + optional free-text
- Reject action includes reasons and comment in the API call
- Approve remains one-click, no rationale prompt
- Criteria with saved field_mappings show clickable entity/relation/value rows in read mode
- AND connector displayed between multiple field mapping rows
- Clicking any field mapping row opens the structured editor with all mappings loaded
</success_criteria>

<output>
After completion, create `.planning/phases/30-ux-polish-editor-pre-loading/30-02-SUMMARY.md`
</output>
