---
phase: 42-pipeline-stability-umls-resilience
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py
  - libs/shared/src/shared/resilience.py
  - services/api-service/src/api_service/terminology_search.py
  - apps/hitl-ui/src/hooks/useTerminologySearch.ts
  - apps/hitl-ui/src/components/TerminologyCombobox.tsx
autonomous: true
requirements: [FIX-B15]

must_haves:
  truths:
    - "ToolUniverse retries on 502/503 with exponential backoff (max 3 attempts)"
    - "Circuit breaker opens after 10 consecutive failures and cools down for 60 seconds"
    - "Frontend shows 'Terminology search temporarily unavailable' when circuit is open"
    - "Sentence-length queries are pre-processed to extract medical terms before searching"
    - "Numeric-only text queries show inline validation hint"
    - "Pipeline grounding gracefully handles circuit open by failing entity for later retry"
  artifacts:
    - path: "services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py"
      provides: "ToolUniverseError exceptions, retry decorator, error-dict detection, sentence extraction"
      contains: "ToolUniverseUnavailableError"
    - path: "libs/shared/src/shared/resilience.py"
      provides: "tu_breaker CircuitBreaker with fail_max=10, reset_timeout=60"
      contains: "tu_breaker"
    - path: "services/api-service/src/api_service/terminology_search.py"
      provides: "503 response when circuit breaker is open"
      contains: "CircuitBreakerError"
    - path: "apps/hitl-ui/src/hooks/useTerminologySearch.ts"
      provides: "isCircuitOpen state tracking from 503 responses"
      contains: "isCircuitOpen"
    - path: "apps/hitl-ui/src/components/TerminologyCombobox.tsx"
      provides: "Circuit open indicator and inline validation hints"
      contains: "temporarily unavailable"
  key_links:
    - from: "libs/shared/src/shared/resilience.py"
      to: "services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py"
      via: "tu_breaker import"
      pattern: "from shared.resilience import tu_breaker"
    - from: "services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py"
      to: "services/api-service/src/api_service/terminology_search.py"
      via: "search_terminology function call"
      pattern: "tu_search"
    - from: "apps/hitl-ui/src/hooks/useTerminologySearch.ts"
      to: "apps/hitl-ui/src/components/TerminologyCombobox.tsx"
      via: "isCircuitOpen prop"
      pattern: "isCircuitOpen"
---

<objective>
Add retry, circuit breaker, query validation, and sentence extraction to the ToolUniverse search layer, with frontend circuit-open indicator.

Purpose: The E2E test report shows 51x 422 errors (bad queries), 17x 503, and 17x 502 against the terminology search API. Without resilience, transient failures cascade to empty grounding results. Without validation, invalid queries waste API calls and produce 422s.

Output: ToolUniverse client with retry+circuit breaker, API endpoint returning 503 on circuit open, React hook tracking circuit state, TerminologyCombobox showing unavailable indicator and validation hints.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-pipeline-stability-umls-resilience/42-RESEARCH.md
@services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py
@libs/shared/src/shared/resilience.py
@services/api-service/src/api_service/terminology_search.py
@apps/hitl-ui/src/hooks/useTerminologySearch.ts
@apps/hitl-ui/src/components/TerminologyCombobox.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: ToolUniverse retry + circuit breaker + query validation</name>
  <files>
    libs/shared/src/shared/resilience.py
    services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py
    services/api-service/src/api_service/terminology_search.py
  </files>
  <action>
**Step 1: Add tu_breaker to resilience.py**

In `libs/shared/src/shared/resilience.py`, add a new circuit breaker:

```python
tu_breaker = CircuitBreaker(
    fail_max=10,          # 10 consecutive failures (NOT reuse _FAIL_MAX=3)
    reset_timeout=60,     # 60 second cooldown
    name="tooluniverse",
    listeners=[_mlflow_listener],
)
```

Do NOT reuse `umls_breaker` — that was for legacy UMLS MCP. Create `tu_breaker` as a new instance with its own fail_max=10 per user decision.

**Step 2: Add exception classes + retry + error detection to tooluniverse_client.py**

At the top of `tooluniverse_client.py`, add:

```python
import logging
import re
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type, before_sleep_log
from shared.resilience import tu_breaker

class ToolUniverseError(Exception):
    """ToolUniverse returned an error dict response."""
    pass

class ToolUniverseUnavailableError(ToolUniverseError):
    """Transient 502/503 error — eligible for retry."""
    pass
```

Add sentence extraction helper (Claude's discretion on approach):

```python
_SENTENCE_WORD_THRESHOLD = 4
_SENTENCE_CHAR_THRESHOLD = 40

_PREAMBLE_PATTERN = re.compile(
    r'^(?:patient(?:s)?\s+(?:must|should|may|with|who|have|has|had|are|is)\s+'
    r'|(?:has|have|had|is|are|must|should|may)\s+(?:a|an|the|confirmed|known|documented|active|history\s+of)\s+'
    r'|(?:history\s+of|presence\s+of|absence\s+of|diagnosis\s+of)\s+)',
    re.IGNORECASE,
)

def _extract_term_from_sentence(query: str) -> str:
    """Extract medical term from sentence-length query."""
    stripped = query.strip()
    word_count = len(stripped.split())
    if word_count < _SENTENCE_WORD_THRESHOLD or len(stripped) < _SENTENCE_CHAR_THRESHOLD:
        return stripped
    cleaned = _PREAMBLE_PATTERN.sub("", stripped).strip()
    if cleaned and cleaned != stripped and len(cleaned) >= 3:
        logger.debug("Extracted term '%s' from sentence '%s'", cleaned, stripped[:60])
        return cleaned
    words = stripped.split()
    return " ".join(words[-min(4, len(words)):])
```

Rename existing `_call_tool()` to `_call_tool_raw()` (just rename, no logic changes).

Create a new resilient wrapper with correct decorator order — `@tu_breaker` (outer) then `@retry` (inner). This means: retry first (3 attempts), then if all fail, count as 1 circuit breaker failure.

NOTE: The `@tu_breaker` decorator is used on an `async def` function. This requires pybreaker >= 1.1 for async support. Confirmed: `libs/shared/pyproject.toml` already specifies `pybreaker>=1.2.0`, so this is safe.

```python
@tu_breaker
@retry(
    retry=retry_if_exception_type(ToolUniverseUnavailableError),
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=2, max=10),
    before_sleep=before_sleep_log(logger, logging.WARNING),
    reraise=True,
)
async def _call_tool_with_resilience(
    tu: ToolUniverse,
    system: str,
    tool_name: str,
    query: str,
    max_results: int,
) -> dict[str, Any]:
    """Call ToolUniverse with retry on transient errors and circuit breaker."""
    raw = await _call_tool_raw(tu, system, tool_name, query, max_results)

    # Detect error dict: ToolUniverse catches HTTP exceptions internally
    # and returns {"error": "..."} dicts instead of raising
    if isinstance(raw, dict) and "error" in raw:
        error_msg = str(raw["error"])
        if any(s in error_msg for s in ("502", "503", "Service Unavailable", "timeout", "Timeout")):
            raise ToolUniverseUnavailableError(f"Transient error: {error_msg}")
        raise ToolUniverseError(f"Non-transient error: {error_msg}")

    return raw
```

Update `search_terminology()` to:
1. Apply sentence extraction: `query = _extract_term_from_sentence(query)` before the cache lookup
2. Call `_call_tool_with_resilience()` instead of `_call_tool()` (rename the call site)
3. Catch `ToolUniverseError` and `pybreaker.CircuitBreakerError` — on CircuitBreakerError, log warning and return cached results from TTLCache if available, otherwise return empty list

Import `pybreaker` at the top:
```python
import pybreaker
```

In the catch block for circuit breaker:
```python
try:
    raw = await _call_tool_with_resilience(tu, system, tool_name, query, max_results)
except pybreaker.CircuitBreakerError:
    logger.warning("Circuit breaker open for ToolUniverse — returning cached/empty results for '%s'", query)
    # Return cached results if available (TTLCache may still have them)
    if use_cache and cache_key in _CACHE:
        return _CACHE[cache_key]
    return []
except ToolUniverseError as e:
    logger.warning("ToolUniverse error for '%s': %s", query, e)
    return []
```

**Step 3: Return 503 from API endpoint when circuit is open**

In `terminology_search.py`, import `pybreaker` and catch `CircuitBreakerError` in the search endpoint. When caught, return 503 (not 502) so the frontend can distinguish circuit-open from generic API failure:

```python
from pybreaker import CircuitBreakerError

# In the except block (add before the generic Exception catch):
except CircuitBreakerError:
    logger.warning("Circuit breaker open — returning 503 for %s search", system)
    raise HTTPException(
        status_code=503,
        detail="Terminology search temporarily unavailable",
    )
```

Also import and catch `ToolUniverseError` to distinguish it from generic exceptions:
```python
from protocol_processor.tools.tooluniverse_client import ToolUniverseError
```

The existing `except Exception` handler returns 502 which is correct for non-circuit errors.
  </action>
  <verify>
1. `grep "tu_breaker" libs/shared/src/shared/resilience.py` — shows fail_max=10, reset_timeout=60
2. `grep "ToolUniverseUnavailableError" services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py` — shows exception class
3. `grep "_call_tool_with_resilience" services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py` — shows retry+breaker decorators
4. `grep "CircuitBreakerError" services/api-service/src/api_service/terminology_search.py` — shows 503 response
5. `grep "_extract_term_from_sentence" services/protocol-processor-service/src/protocol_processor/tools/tooluniverse_client.py` — shows sentence extraction
  </verify>
  <done>
ToolUniverse calls retry 3 times on 502/503 with exponential backoff. Circuit breaker trips after 10 failures and cools down for 60s. API returns 503 when circuit is open. Sentence-length queries are pre-processed to extract the medical term. Error dicts from ToolUniverse SDK are converted to exceptions for retry/breaker interception.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend circuit-open indicator and query validation hints</name>
  <files>
    apps/hitl-ui/src/hooks/useTerminologySearch.ts
    apps/hitl-ui/src/components/TerminologyCombobox.tsx
  </files>
  <action>
**Step 1: Track circuit-open state in useTerminologySearch.ts**

Add `isCircuitOpen` state to the hook:

```typescript
const [isCircuitOpen, setIsCircuitOpen] = useState(false);
```

In the `queryFn`, detect 503 specifically (before the generic `!response.ok` check):

```typescript
if (response.status === 503) {
    setIsCircuitOpen(true);
    throw new Error('Terminology service temporarily unavailable');
}
if (response.ok) {
    setIsCircuitOpen(false);  // Reset on successful response
}
```

Update the return type and return value to include `isCircuitOpen`:

```typescript
return {
    results: data ?? [],
    isLoading: isFetching,
    isError,
    isCircuitOpen,
};
```

Update the function return type annotation to include `isCircuitOpen: boolean`.

**Step 2: Add numeric-only validation to useTerminologySearch.ts**

Add a query validation check. The existing `enabled` check is `debouncedQuery.trim().length >= 3`. Add an additional check:

```typescript
// Numeric-only queries are invalid for text name search
const isNumericOnly = /^\d+$/.test(debouncedQuery.trim());
const enabled = debouncedQuery.trim().length >= 3 && !isNumericOnly;
```

Also expose `validationHint` from the hook:

```typescript
const validationHint = (() => {
    const trimmed = debouncedQuery.trim();
    if (trimmed.length > 0 && trimmed.length < 3) return 'Type at least 3 characters';
    if (isNumericOnly && trimmed.length >= 3) return 'Enter a term name, not a code number';
    if (isCircuitOpen) return 'Terminology search temporarily unavailable';
    return null;
})();
```

Return `validationHint` from the hook (add to return type: `validationHint: string | null`).

**Step 3: Show circuit-open indicator and validation hints in TerminologyCombobox.tsx**

Update the component to consume `isCircuitOpen` and `validationHint` from the hook:

```typescript
const { results, isLoading, isError, isCircuitOpen, validationHint } = useTerminologySearch(system, inputValue);
```

Add an inline hint below the input (NOT inside the popover — always visible when relevant):

```tsx
{validationHint && (
    <p className="mt-1 text-xs text-amber-600">
        {validationHint}
    </p>
)}
```

Place this `<p>` immediately after the closing `</Popover.Root>` tag, wrapping both in a fragment or parent div.

When `isCircuitOpen` is true AND there are cached results, show results normally but add a small amber indicator. When `isCircuitOpen` AND no cached results, show the inline hint (handled by validationHint).

Replace the existing "Type at least 3 characters" `Command.Empty` block with a check that includes the validation hint (to avoid duplicating the message). The existing block at lines 96-103 shows "Type at least 3 characters" inside the popover — keep that for the popover context, but the inline hint below the input provides the primary feedback per user decision ("inline hint below search box").
  </action>
  <verify>
1. `grep "isCircuitOpen" apps/hitl-ui/src/hooks/useTerminologySearch.ts` — shows state tracking
2. `grep "isCircuitOpen" apps/hitl-ui/src/components/TerminologyCombobox.tsx` — shows consumption
3. `grep "validationHint" apps/hitl-ui/src/hooks/useTerminologySearch.ts` — shows validation logic
4. `grep "temporarily unavailable" apps/hitl-ui/src/components/TerminologyCombobox.tsx` — shows indicator
5. `grep "isNumericOnly" apps/hitl-ui/src/hooks/useTerminologySearch.ts` — shows numeric validation
  </verify>
  <done>
useTerminologySearch tracks 503 as circuit-open state and exposes isCircuitOpen + validationHint. TerminologyCombobox shows inline amber hint for: too-short queries, numeric-only queries, and circuit-open state. Cached results (React Query stale data via `data ?? []`) continue to display when circuit is open.
  </done>
</task>

</tasks>

<verification>
1. Backend: tooluniverse_client.py has @tu_breaker + @retry decorators on _call_tool_with_resilience
2. Backend: terminology_search.py returns 503 on CircuitBreakerError
3. Backend: resilience.py has tu_breaker with fail_max=10, reset_timeout=60
4. Frontend: useTerminologySearch tracks isCircuitOpen from 503 responses
5. Frontend: TerminologyCombobox shows inline validation hints and circuit-open indicator
6. Query validation: numeric-only rejected, sentence-length extracted, 3-char minimum preserved
</verification>

<success_criteria>
- ToolUniverse calls wrapped with @tu_breaker (fail_max=10, reset_timeout=60) and @retry (3 attempts, exponential backoff)
- Error dicts from ToolUniverse SDK detected and converted to ToolUniverseUnavailableError for transient errors
- API returns 503 when circuit breaker is open
- Frontend tracks isCircuitOpen and shows "Terminology search temporarily unavailable" indicator
- Numeric-only queries blocked with inline hint "Enter a term name, not a code number"
- Sentence-length queries pre-processed via _extract_term_from_sentence before API call
- Cached results served via React Query stale data when circuit is open
</success_criteria>

<output>
After completion, create `.planning/phases/42-pipeline-stability-umls-resilience/42-02-SUMMARY.md`
</output>
