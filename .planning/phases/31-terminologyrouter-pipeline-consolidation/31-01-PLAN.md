---
phase: 31-terminologyrouter-pipeline-consolidation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/protocol-processor-service/pyproject.toml
  - services/protocol-processor-service/src/protocol_processor/__init__.py
  - services/protocol-processor-service/src/protocol_processor/state.py
  - services/protocol-processor-service/src/protocol_processor/config/__init__.py
  - services/protocol-processor-service/src/protocol_processor/config/routing.yaml
  - services/protocol-processor-service/src/protocol_processor/tools/__init__.py
  - services/protocol-processor-service/src/protocol_processor/tools/terminology_router.py
  - services/protocol-processor-service/src/protocol_processor/schemas/__init__.py
  - services/protocol-processor-service/src/protocol_processor/schemas/grounding.py
  - services/protocol-processor-service/tests/__init__.py
  - services/protocol-processor-service/tests/test_terminology_router.py
autonomous: true

must_haves:
  truths:
    - "TerminologyRouter loads YAML config and returns correct API list per entity type"
    - "Demographic entities are explicitly skipped (not silently dropped)"
    - "PipelineState TypedDict carries minimal fields needed for 5-node pipeline"
    - "UMLS client imported via direct Python import (not MCP subprocess)"
    - "Entity routing config is editable YAML, not hardcoded"
  artifacts:
    - path: "services/protocol-processor-service/src/protocol_processor/state.py"
      provides: "Minimal PipelineState TypedDict"
      contains: "class PipelineState"
    - path: "services/protocol-processor-service/src/protocol_processor/tools/terminology_router.py"
      provides: "Entity-type-aware routing to terminology APIs"
      contains: "class TerminologyRouter"
    - path: "services/protocol-processor-service/src/protocol_processor/config/routing.yaml"
      provides: "Entity type → API mapping config"
      contains: "routing_rules"
    - path: "services/protocol-processor-service/src/protocol_processor/schemas/grounding.py"
      provides: "Pydantic schemas for grounding results and API candidates"
      contains: "class GroundingCandidate"
    - path: "services/protocol-processor-service/tests/test_terminology_router.py"
      provides: "Tests for TerminologyRouter routing logic"
  key_links:
    - from: "services/protocol-processor-service/src/protocol_processor/tools/terminology_router.py"
      to: "services/protocol-processor-service/src/protocol_processor/config/routing.yaml"
      via: "yaml.safe_load"
      pattern: "yaml\\.safe_load"
    - from: "services/protocol-processor-service/src/protocol_processor/tools/terminology_router.py"
      to: "umls_mcp_server"
      via: "direct Python import"
      pattern: "from umls_mcp_server"
---

<objective>
Create the protocol-processor-service skeleton with PipelineState, YAML-based entity routing config, and TerminologyRouter that routes entities to terminology APIs by entity type.

Purpose: Foundation for the consolidated 5-node pipeline — establishes the service structure, minimal state design, and routing infrastructure that all other plans depend on.
Output: New service directory with PipelineState TypedDict, TerminologyRouter class, YAML routing config, grounding schemas, and routing tests.
</objective>

<execution_context>
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/workflows/execute-plan.md
@/Users/noahdolevelixir/.claude-elixirtrials/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-terminologyrouter-pipeline-consolidation/31-CONTEXT.md
@.planning/phases/31-terminologyrouter-pipeline-consolidation/31-RESEARCH.md
@services/grounding-service/src/grounding_service/umls_client.py
@services/grounding-service/src/grounding_service/nodes/medgemma_ground.py
@services/grounding-service/src/grounding_service/schemas/entities.py
@services/grounding-service/src/grounding_service/schemas/agentic_actions.py
@services/grounding-service/src/grounding_service/state.py
@services/umls-mcp-server/src/umls_mcp_server/umls_api.py
@services/extraction-service/src/extraction_service/state.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protocol-processor-service skeleton with PipelineState and grounding schemas</name>
  <files>
    services/protocol-processor-service/pyproject.toml
    services/protocol-processor-service/src/protocol_processor/__init__.py
    services/protocol-processor-service/src/protocol_processor/state.py
    services/protocol-processor-service/src/protocol_processor/schemas/__init__.py
    services/protocol-processor-service/src/protocol_processor/schemas/grounding.py
    services/protocol-processor-service/src/protocol_processor/tools/__init__.py
    services/protocol-processor-service/src/protocol_processor/nodes/__init__.py
    services/protocol-processor-service/src/protocol_processor/config/__init__.py
    services/protocol-processor-service/tests/__init__.py
    pyproject.toml (workspace member addition)
  </files>
  <action>
    1. Create `services/protocol-processor-service/` directory structure matching the architecture from 31-RESEARCH.md:
       - `src/protocol_processor/` with `__init__.py`
       - `src/protocol_processor/nodes/` with `__init__.py`
       - `src/protocol_processor/tools/` with `__init__.py`
       - `src/protocol_processor/schemas/` with `__init__.py`
       - `src/protocol_processor/config/` with `__init__.py`
       - `tests/` with `__init__.py`

    2. Create `pyproject.toml` for the new service:
       - Name: `protocol-processor-service`
       - Dependencies: `langgraph`, `pydantic`, `google-genai`, `tenacity`, `sqlmodel`, `structlog`, `pyyaml`, `jinja2`
       - Add workspace dependency references to `shared`, `events-py`, `inference`, `umls-mcp-server` (same pattern as extraction-service and grounding-service pyproject.toml files)
       - Add the new service as a workspace member in the root `pyproject.toml`

    3. Create `state.py` with minimal `PipelineState(TypedDict)`:
       ```python
       class PipelineState(TypedDict):
           # Input (always present)
           protocol_id: str
           file_uri: str
           title: str

           # Created by parse node
           batch_id: str | None

           # Processing artifacts (populated on-demand)
           pdf_bytes: bytes | None          # Populated by ingest, used by extract
           extraction_json: str | None      # Populated by extract, used by parse
           entities_json: str | None        # Populated by parse/ground
           grounded_entities_json: str | None  # Populated by ground, used by persist

           # Output
           status: Literal["processing", "completed", "failed"]
           error: str | None
           errors: list[str]  # Accumulate partial failures per user decision
       ```
       Key: Use `str | None` for JSON string fields (not nested dicts) to minimize token/state overhead per 31-RESEARCH Pattern 2.

    4. Create `schemas/grounding.py` with Pydantic models for machine-readable agent communication:
       - `GroundingCandidate(BaseModel)`: source_api (str), code (str), preferred_term (str), semantic_type (str | None), score (float)
       - `EntityGroundingResult(BaseModel)`: entity_text (str), entity_type (str), selected_code (str | None), selected_system (str | None), preferred_term (str | None), confidence (float), candidates (list[GroundingCandidate]), reasoning (str), field_mappings (list[dict] | None)
       - `GroundingBatchResult(BaseModel)`: results (list[EntityGroundingResult]), errors (list[str])
       These schemas are the machine-readable format between TerminologyRouter → MedGemma decision per user decision "agent-to-agent communication must be machine-readable."
  </action>
  <verify>
    - `uv run python -c "from protocol_processor.state import PipelineState; print('OK')"` succeeds
    - `uv run python -c "from protocol_processor.schemas.grounding import GroundingCandidate, EntityGroundingResult; print('OK')"` succeeds
    - `uv run ruff check services/protocol-processor-service/` passes
    - `uv run mypy services/protocol-processor-service/src/` passes (or only has non-blocking warnings)
  </verify>
  <done>
    New service package is importable, PipelineState TypedDict defined with minimal fields, Pydantic grounding schemas defined with machine-readable structure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create YAML routing config and TerminologyRouter with tests</name>
  <files>
    services/protocol-processor-service/src/protocol_processor/config/routing.yaml
    services/protocol-processor-service/src/protocol_processor/tools/terminology_router.py
    services/protocol-processor-service/tests/test_terminology_router.py
  </files>
  <action>
    1. Create `config/routing.yaml` per user decision "Entity type → API mapping stored in config file (YAML)":
       ```yaml
       routing_rules:
         Medication:
           - rxnorm
           - umls
         Condition:
           - icd10
           - snomed
           - umls
         Lab_Value:
           - loinc
           - umls
         Biomarker:
           - hpo
           - umls
         Procedure:
           - umls
           - snomed
         Phenotype:
           - hpo
           - umls
         Demographic:
           skip: true  # Demographics not grounded to terminology

       api_configs:
         rxnorm:
           source: tooluniverse
           tool_name: "rxnorm_search"
         icd10:
           source: tooluniverse
           tool_name: "icd10_search"
         loinc:
           source: tooluniverse
           tool_name: "loinc_search"
         hpo:
           source: tooluniverse
           tool_name: "hpo_search"
         umls:
           source: direct_python
           module: "umls_mcp_server.umls_api"
         snomed:
           source: direct_python
           module: "grounding_service.umls_client"
       ```

    2. Create `tools/terminology_router.py` with `TerminologyRouter` class:
       - `__init__(self, config_path: Path | None = None)`: Load YAML config; default path is `config/routing.yaml` relative to package.
       - `get_apis_for_entity(self, entity_type: str) -> list[str]`: Return API names for entity type. Return empty list and log skip for Demographic. Log warning for unknown entity types (GRND-06: unroutable types explicitly skipped with logging, not silently dropped).
       - `async route_entity(self, entity_text: str, entity_type: str) -> list[GroundingCandidate]`: Query all matching APIs, return candidates. Use tenacity retry with `retry_if_exception_type(TransientAPIError)` per 31-RESEARCH Pitfall 4. Continue on individual API failure (error accumulation). Each candidate tagged with `source_api`.
       - Private methods `_query_umls(entity_text)`, `_query_snomed(entity_text, cui)`: Use direct Python import from `umls_mcp_server.umls_api` and `grounding_service.umls_client` (GRND-02: not MCP subprocess).
       - Private method `_query_tooluniverse(tool_name, entity_text)`: Placeholder that will use ToolUniverse Python SDK. For now, implement as a stub that returns empty list with a TODO comment — ToolUniverse medical tool availability needs validation (from 31-RESEARCH Open Question 1). The UMLS/SNOMED direct path must work fully.
       - Define `TransientAPIError` and `PermanentAPIError` exception classes for retry classification.

    3. Create `tests/test_terminology_router.py`:
       - Test `get_apis_for_entity("Medication")` returns `["rxnorm", "umls"]`
       - Test `get_apis_for_entity("Demographic")` returns `[]` (skip)
       - Test `get_apis_for_entity("UnknownType")` returns `[]` with warning logged
       - Test `get_apis_for_entity("Condition")` returns `["icd10", "snomed", "umls"]`
       - Test YAML config loads correctly
       - Test custom config path works
  </action>
  <verify>
    - `uv run pytest services/protocol-processor-service/tests/test_terminology_router.py -v` — all tests pass
    - `uv run ruff check services/protocol-processor-service/` passes
    - `uv run python -c "from protocol_processor.tools.terminology_router import TerminologyRouter; print('OK')"` succeeds
  </verify>
  <done>
    TerminologyRouter routes entities to correct APIs based on YAML config. Demographic entities explicitly skipped with logging. Unknown entity types logged as warnings, not silently dropped. UMLS/SNOMED accessed via direct Python import. ToolUniverse stub ready for validation. Tests pass.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest services/protocol-processor-service/ -v` — all tests pass
2. `uv run ruff check services/protocol-processor-service/` — clean
3. `uv run mypy services/protocol-processor-service/src/` — no blocking errors
4. YAML routing config covers all entity types from roadmap (Medication, Condition, Lab_Value, Biomarker, Procedure, Phenotype, Demographic)
5. TerminologyRouter correctly skips Demographic with logging
</verification>

<success_criteria>
- New `services/protocol-processor-service/` exists with proper package structure
- PipelineState TypedDict has minimal flat fields (no nested dicts)
- TerminologyRouter loads routing.yaml and returns correct APIs per entity type
- Grounding Pydantic schemas defined for machine-readable agent communication
- All tests pass, linting clean
</success_criteria>

<output>
After completion, create `.planning/phases/31-terminologyrouter-pipeline-consolidation/31-01-SUMMARY.md`
</output>
