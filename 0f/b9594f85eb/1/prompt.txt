Implement the following plan:

# Phase 3b: Ordinal Scale Normalization with Agent-Assisted Concept Resolution

## Context

Phase 3 unit/value normalization is complete (157 tests). But ordinal scoring systems (ECOG, Karnofsky, NYHA, Child-Pugh, GCS, APACHE, etc.) get `unit_concept_id = None` and `value_concept_id = None` because the normalizer is context-free and skips numeric values.

## Design Philosophy: Lookup → Agent → Approve → Persist

Instead of hardcoding all OMOP concept IDs upfront (which requires Athena verification), the system uses a three-tier resolution pattern:

1. **Lookup**: Check YAML config for a previously-approved mapping → use it immediately
2. **Agent**: If not found, an LLM agent proposes a mapping (SNOMED code → OMOP concept ID resolution)
3. **Approve & Persist**: Human reviews the proposal, approves/modifies it, and it gets written back to the YAML for all future lookups

This means the YAML starts with **structural knowledge** (entity aliases, LOINC codes, SNOMED codes — all verifiable from public sources) but OMOP concept IDs are populated incrementally through the agent/approval workflow.

## Research Summary

- `{score}` (OMOP 8527) is the standard UCUM unit for ordinal scales ([LOINC 89247-1](https://loinc.org/89247-1) uses `{score}` as its example unit)
- ECOG: [LOINC 89247-1](https://loinc.org/89247-1), answer list [LL529-9](https://loinc.org/LL529-9), answer codes LA9622-7 through LA9627-6
- SNOMED CT ECOG grades: 425389002 (grade 0) through 423409001 (grade 5) — verified via [BioPortal](https://bioportal.bioontology.org/ontologies/SNOMEDCT?p=classes&conceptid=424122007)
- No new DB column needed — `unit_concept_id` + `value_concept_id` + `entity_concept_id` fully describe ordinal measurements per [OMOP CDM v5.4](https://ohdsi.github.io/CommonDataModel/cdm54.html)
- Positive/negative results keep `unit_concept_id = NULL` per OMOP standard

## Files to Modify

| File | Change |
|------|--------|
| `config/ucum_mappings.yaml` | Add `{score}` unit + `ordinal_scales` section (structural + SNOMED, no hardcoded OMOP IDs initially) |
| `tools/unit_normalizer.py` | Add `_load_ordinal_scales()`, `normalize_ordinal_value()`, `propose_ordinal_mappings()` |
| `tools/structure_builder.py` | Update import + ordinal-first dispatch in `_create_atomic_from_mapping()` |
| `tests/test_unit_normalizer.py` | Add `TestNormalizeOrdinalValue` class (~18 tests) |
| `tests/test_phase3_integration.py` | Update ECOG expected values + add ordinal criteria tests |

## Step 1: YAML Structure

Add `{score}` to the existing `units:` list:
```yaml
  - canonical: "{score}"
    omop_unit_concept_id: 8527
    aliases: ["score", "points"]
```

Add `ordinal_scales:` top-level section. Note: `omop_value_concept_id` is **optional** per value — starts `null` until resolved by the agent/approval workflow. The SNOMED codes and LOINC answer codes are factual and present from the start.

```yaml
ordinal_scales:
  ecog:
    entity_aliases:
      - "ECOG"
      - "ECOG performance status"
      - "ECOG PS"
      - "Eastern Cooperative Oncology Group"
      - "WHO performance status"
      - "Zubrod score"
    loinc_code: "89247-1"
    loinc_answer_list: "LL529-9"
    unit_concept_id: 8527  # {score} — verified OMOP standard
    values:
      "0": { snomed_code: "425389002", loinc_answer: "LA9622-7", description: "Fully active" }
      "1": { snomed_code: "422512005", loinc_answer: "LA9623-5", description: "Restricted" }
      "2": { snomed_code: "422894000", loinc_answer: "LA9624-3", description: "Ambulatory, no work" }
      "3": { snomed_code: "423053003", loinc_answer: "LA9625-0", description: "Limited selfcare" }
      "4": { snomed_code: "423237006", loinc_answer: "LA9626-8", description: "Completely disabled" }
      "5": { snomed_code: "423409001", loinc_answer: "LA9627-6", description: "Dead" }

  karnofsky:
    entity_aliases:
      - "Karnofsky"
      - "KPS"
      - "Karnofsky performance status"
      - "Karnofsky performance scale"
    loinc_code: "89243-0"
    loinc_answer_list: "LL4986-7"
    unit_concept_id: 8527
    values:
      "100": { description: "Normal, no complaints" }
      "90":  { description: "Able to carry on normal activity" }
      "80":  { description: "Normal activity with effort" }
      "70":  { description: "Cares for self, unable to do active work" }
      "60":  { description: "Requires occasional assistance" }
      "50":  { description: "Requires considerable assistance" }
      "40":  { description: "Disabled, requires special care" }
      "30":  { description: "Severely disabled, hospitalization indicated" }
      "20":  { description: "Very sick, active supportive treatment" }
      "10":  { description: "Moribund" }
      "0":   { description: "Dead" }

  nyha:
    entity_aliases:
      - "NYHA"
      - "NYHA class"
      - "NYHA functional class"
      - "New York Heart Association"
      - "NYHA classification"
    loinc_code: "88020-3"
    unit_concept_id: 8527
    values:
      "1": { snomed_code: "420300004", description: "No limitation" }
      "2": { snomed_code: "421704003", description: "Slight limitation" }
      "3": { snomed_code: "420913000", description: "Marked limitation" }
      "4": { snomed_code: "422293003", description: "Unable without discomfort" }
```

Adding new scales (Child-Pugh, GCS, APACHE, etc.) is a YAML-only change — no code modifications needed.

## Step 2: `normalize_ordinal_value()` in `unit_normalizer.py`

New `@lru_cache` loader + two public functions. Existing APIs untouched.

```python
@lru_cache(maxsize=1)
def _load_ordinal_scales() -> tuple[dict[str, str], dict[str, Any]]:
    """Returns (alias_to_scale, scale_defs)."""
```

**Public function 1 — runtime normalization:**
```python
def normalize_ordinal_value(
    value_text: str | None,
    entity_text: str | None = None,
) -> tuple[int | None, int | None] | None:
    """Entity-context-aware ordinal value normalization.

    Returns:
        (value_concept_id, unit_concept_id) if entity matches an ordinal scale.
        value_concept_id is the approved OMOP ID from YAML (or None if not yet resolved).
        unit_concept_id is always 8527 ({score}) for ordinal scales.
        Returns None (not a tuple) if entity doesn't match any ordinal scale.
    """
```

Key behaviors:
- Entity matching: exact alias first, then bidirectional substring containment (case-insensitive)
- Value parsing: strips "grade"/"stage"/"class"/"score" prefixes, normalizes "2.0"→"2"
- Returns `omop_value_concept_id` from YAML if present, `None` if not yet resolved
- Always returns `unit_concept_id=8527` for recognized ordinal entities
- Returns Python `None` (not a tuple) for non-ordinal entities → signals fall-through

**Public function 2 — agent proposal utility:**
```python
def propose_ordinal_mappings() -> list[dict[str, Any]]:
    """Scan ordinal_scales config and return entries missing omop_value_concept_id.

    Returns a list of dicts, each with:
      - scale: scale key (e.g., "ecog")
      - grade: value string (e.g., "2")
      - snomed_code: known SNOMED code (if any)
      - loinc_answer: known LOINC answer code (if any)
      - description: human-readable description
      - status: "needs_resolution"

    This output can be fed to an LLM agent or OMOP vocabulary lookup to propose
    omop_value_concept_id values. Once approved, add them to the YAML.
    """
```

This is a read-only utility — it identifies gaps. A future agent (or manual Athena lookup) fills them. Once an `omop_value_concept_id` is added to the YAML and approved, the normalizer uses it automatically on next cache refresh.

## Step 3: Update `structure_builder.py` call site

In `_create_atomic_from_mapping()`, add ordinal-first dispatch:

```python
from protocol_processor.tools.unit_normalizer import (
    normalize_ordinal_value, normalize_unit, normalize_value,
)

# After _parse_value()...
raw_unit = fm.get("unit")
_, unit_concept_id = normalize_unit(raw_unit)

value_concept_id: int | None = None
entity_text = fm.get("entity")
raw_value = str(fm.get("value", ""))

# Ordinal-first: check if entity is an ordinal scale
ordinal_result = normalize_ordinal_value(raw_value, entity_text)
if ordinal_result is not None:
    ordinal_value_cid, ordinal_unit_cid = ordinal_result
    value_concept_id = ordinal_value_cid
    if ordinal_unit_cid is not None:
        unit_concept_id = ordinal_unit_cid
elif value_text and value_numeric is None:
    _, value_concept_id = normalize_value(value_text)
```

Result for ECOG <= 2: `value_numeric=2.0` (for comparison) + `unit_concept_id=8527` + `value_concept_id=<OMOP ID once approved, None until then>`.

## Step 4: Tests

**`test_unit_normalizer.py`** — Add `TestNormalizeOrdinalValue` (~18 tests):
- Entity matching: exact alias, full name, case-insensitive, substring ("ECOG PS")
- ECOG: all 6 grades recognized (unit_concept_id=8527 for each), grades are distinct where OMOP IDs exist
- Edge cases: "2.0"→"2", "Grade 2" prefix strip, unknown grade 7 → `(None, 8527)`
- Non-ordinal: "HbA1c" → `None`, None/empty entity → `None`
- `{score}` unit: `normalize_unit("score")` → 8527
- `propose_ordinal_mappings()`: returns entries missing OMOP IDs

**`test_phase3_integration.py`** — Update existing + add:
- ECOG criterion #11: `unit_concept_id` changes None → 8527
- Coverage counts updated
- New Karnofsky criterion: verify unit_concept_id=8527

## Verification

1. `uv run pytest tests/test_unit_normalizer.py -v` — 30 existing + ~18 new pass
2. `uv run pytest tests/test_phase3_integration.py -v` — updated expectations pass
3. `uv run pytest tests/ -v` — full suite green
4. `uv run ruff check .` — clean
5. `propose_ordinal_mappings()` returns a list of entries needing OMOP ID resolution
6. After adding an OMOP ID to YAML → normalizer returns it on next invocation


If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/noahdolevelixir/.REDACTED.jsonl

---

test the backend end to end with a few examples to see that everything works

---

Try again with a concept not currently hardcoded

---

No, the unknown should trigger a node on the langgraph.

---

[Request interrupted by user for tool use]