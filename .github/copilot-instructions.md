# GitHub Copilot instructions for this repository — Quick reference

Purpose: give an AI coding agent the minimum, high‑signal knowledge to be productive here (run, test, navigate, and change code safely).

## 1) Big picture (one-liner)
- Monorepo of small Python services (FastAPI), LangGraph agent packages, an inference layer, data pipelines, evaluation code and a React/Vite HITL UI. Docs are generated with MkDocs (monorepo plugin + mkdocstrings).
- Key dirs: `services/{api-service,agent-*}`; `libs/{inference,data-pipeline,model-training,shared,events-py,events-ts,shared-ts}`; `apps/hitl-ui`.

## 2) Quick start — concrete commands (exact)
- Full stack (recommended for end-to-end work):
  - docker: `docker-compose -f infra/docker-compose.yml up --build` (from repo root)
- API (dev):
  - ensure deps: `uv sync --all-extras`
  - run (dev reload): `uv run uvicorn api_service.main:app --reload`
  - health/readiness: `GET /health` and `GET /ready`
- Frontend (HITL UI):
  - `cd apps/hitl-ui && npm ci && npm run dev` (env: `VITE_API_BASE_URL`)
- Tests (per-component):
  - `uv run pytest --cov=./src/<package> .` or use `make run-tests` in a component with the generated `Makefile`
- Docs/OpenAPI:
  - build docs: `uv run mkdocs build -f mkdocs.yml`
  - export API schema: `python services/api-service/scripts/export_openapi.py`
- Useful repo scripts:
  - Create service scaffold: `scripts/create-service.sh [--lang py|ts] [--lib | --app] <name>` (services/ by default; use --lib for libs/, --app for apps/)
  - Regenerate nav: `python scripts/update_root_navigation.py`
  - Kill local dev processes: `scripts/kill-running-processes.sh`

## 3) Architecture & integration (what to know)
- API Service (`services/api-service`): FastAPI orchestrator, DB (Postgres), MLFlow; exposes REST used by HITL UI and other components.
- Agent packages (`services/agent-*/`): LangGraph StateGraphs — graph in `graph.py`, nodes in `nodes.py`, typed state in `state.py`. Prefer invoking via graph factories (e.g. `create_graph()`), not by importing internal runtime elsewhere.
- Inference layer: central model-loading / call interface — agents call it rather than calling models directly.
- Docs: each component has its own `mkdocs.yml` and is included into the root `mkdocs.yml` via `!include` (see `scripts/update_root_navigation.py`).

## 4) Project-specific conventions (do this, not generic advice)
- Component layout: `services/<name>/` or `libs/<name>/` or `apps/<name>/` with `src/<snake_name>/`, `tests/`, `mkdocs.yml`, `pyproject.toml`; Python packages may have `src/<pkg>/notebooks/playground.ipynb` for quick manual checks.
- Tooling is driven by the `uv` CLI (astral-sh/uv). Use `uv sync`, `uv run <tool>` (CI relies on this). Do not bypass `uv` for installs/commands in CI-contexts.
- API endpoints: add routers under `src/api_service/routers/` and register them in `src/api_service/main.py` (example in `services/api-service/README.md`).
- Testing: `pythonpath = ["src"]` per-component — tests import from `src` directly. Coverage and pytest-cov are standard in CI.
- Docs: API reference is autogenerated via `mkdocstrings[python]` — public docstrings (Google style) and module export directives in `docs/api/index.md` are canonical examples.

## 5) Common patterns & pitfalls (actionable)
- Do: use `Depends()` for DB/session injection and background tasks for long-running work (see `services/api-service/src/api_service/main.py`).
- Don’t: import agent implementation into the API — use agent factories / inference interfaces (`libs/inference` / agent `create_graph()`).
- Keep `libs/shared` tiny and dependency-free (no business logic).
- Frontend expects API at `VITE_API_BASE_URL`; changing API base URL requires updating `infra/docker-compose.yml` and HMR env for dev.

## 6) Where to look (highest signal files)
- Run & wiring: `services/api-service/src/api_service/main.py` (health/readiness, lifespan)
- Agent canonical example: `services/agent-a-service/{graph.py,nodes.py,state.py,notebooks/playground.ipynb}`
- CI / commands: `.github/workflows/ci.yml` (shows `uv` usage, JS workflow)
- Dev compose: `infra/docker-compose.yml` (run from root with `-f infra/docker-compose.yml`; service envs: Postgres, MLflow, VITE_API_BASE_URL)
- Docs/nav automation: `scripts/update_root_navigation.py`, `scripts/generate_components_overview.py`
- OpenAPI export: `services/api-service/scripts/export_openapi.py`

## 7) Typical edit tasks — exact steps for an AI to propose or implement
- Add a new API endpoint:
  1) create `src/api_service/routers/<name>.py` with typed Pydantic models
  2) register in `src/api_service/main.py` (include_router)
  3) add unit tests under the corresponding `tests/` folder
  4) run `uv run pytest tests/test_<new>.py` and `make typecheck` (or the explicit mypy paths in CI; do not use `libs/*/src` — it includes TypeScript libs)
  5) update docs by adding module to the component `docs/api/index.md` and run `uv run mkdocs build -f mkdocs.yml`
- Add/modify an agent node:
  - edit `nodes.py` + update `graph.py`; add a small notebook example in `notebooks/`; test via `pytest` and the notebook.

## 8) CI & linting expectations
- Use `uv run ruff` for linting and `uv run mypy` for type checks (CI enforces both). Keep line-length ~88 and Google docstring style where present.

## 9) Safety & review notes for PRs
- Include unit tests for new behavior and minimal integration smoke for API surface (health + example request).
- When changing shared models, check all consumers (shared is widely imported).
- If adding infra (DB table, MLflow), include migration + README snippet showing `uv run alembic ...` (examples in `services/api-service/README.md`).

---
If any section is unclear or you want a shorter/longer variant (e.g., a checklist for reviewers or an agent prompt template), tell me which area to expand and I will iterate. ✅
